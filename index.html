<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bridd Jump with Trail</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      background: #111;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.8);
    }
    #menu button {
      font-family: 'Press Start 2P', monospace;
      font-size: 14px;
      padding: 10px 20px;
      margin: 8px;
      cursor: pointer;
    }
    #fpsOverlay {
      position: absolute;
      top: 6px;
      left: 8px;
      font-family: 'Press Start 2P', monospace;
      font-size: 12px;
      color: white;
      z-index: 1500;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="menu">
    <button id="startBtn">START</button>
    <button id="settingsBtn">SETTINGS</button>
  </div>
  <div id="fpsOverlay"></div>
  <canvas id="gameCanvas"></canvas>

  <script>
  // === SETTINGS LOADER ===
  function safeLoadSettings() {
    try {
      const raw = localStorage.getItem("briddSettings");
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (e) {
      return null;
    }
  }

  let settings = safeLoadSettings();
  if (!settings) {
    try {
      fetch("settings.html", { method: "HEAD" })
        .then(r => {
          if (r.ok) {
            window.location.href = "settings.html";
          } else {
            alert("cannot open settings, settings.html required");
          }
        })
        .catch(() => {
          alert("cannot open settings, settings.html required");
        });
    } catch (err) {
      alert("cannot open settings, settings.html required");
    }
  }

  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  let W = window.innerWidth;
  let H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;

  window.addEventListener("resize", () => {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  });

  // === STATE ===
  let gameRunning = false;
  let fpsOverlay = document.getElementById("fpsOverlay");

  // defaults
  let runtime = {
    fps: 60,
    quality: "Extreme+",
    effects: {
      jump: 64,
      walk: 64,
      die: 64,
      lines: 64,
      gem: 0,
      trail: 0
    },
    glow: 100,
    blockTexture: true
  };

  function applySettings() {
    if (!settings) return;
    runtime.fps = settings.fps ?? 60;
    runtime.quality = settings.quality ?? "Extreme+";
    runtime.effects.jump = settings.jump ?? 64;
    runtime.effects.walk = settings.walk ?? 64;
    runtime.effects.die = settings.die ?? 64;
    runtime.effects.lines = settings.lines ?? 64;
    runtime.effects.gem = settings.gem ?? 64;
    runtime.effects.trail = settings.trail ?? 0;
    runtime.glow = settings.glow ?? 100;
    runtime.blockTexture = settings.block ?? true;
  }

  applySettings();

  // === MENU BUTTONS ===
  document.addEventListener("DOMContentLoaded", () => {
    const startBtn = document.getElementById("startButton");
    const settingsBtn = document.getElementById("settingsButton");

    startBtn.addEventListener("click", () => {
      document.getElementById("menu").style.display = "none";
      startGame();
    });

    settingsBtn.addEventListener("click", () => {
      try {
        fetch("settings.html", { method: "HEAD" })
          .then(r => {
            if (r.ok) {
              window.location.href = "settings.html";
            } else {
              alert("cannot open settings, settings.html required");
            }
          })
          .catch(() => {
            alert("cannot open settings, settings.html required");
          });
      } catch (e) {
        alert("cannot open settings, settings.html required");
      }
    });
  });

  // === GAME OBJECTS ===
  class Player {
    constructor() {
      this.x = 100;
      this.y = H - 200;
      this.vx = 0;
      this.vy = 0;
      this.onGround = false;
      this.dead = false;
      this.trail = [];
    }
    update() {
      this.vy += 0.5;
      this.x += this.vx;
      this.y += this.vy;
      if (this.y > H - 50) {
        this.y = H - 50;
        this.vy = 0;
        this.onGround = true;
      } else {
        this.onGround = false;
      }
      if (runtime.effects.trail > 0) {
        this.trail.push({x: this.x, y: this.y, life: 1});
        if (this.trail.length > 50) this.trail.shift();
      }
    }
    draw() {
      ctx.save();
      if (runtime.glow > 0) {
        ctx.shadowBlur = runtime.glow;
        ctx.shadowColor = "cyan";
      }
      ctx.fillStyle = "cyan";
      ctx.fillRect(this.x-15, this.y-15, 30, 30);
      ctx.restore();
      if (runtime.effects.trail > 0) {
        ctx.fillStyle = "rgba(0,255,255,0.5)";
        for (let t of this.trail) {
          ctx.globalAlpha = t.life;
          ctx.fillRect(t.x-10, t.y-10, 20, 20);
        }
        ctx.globalAlpha = 1;
      }
    }
  }

  class Particle {
    constructor(x,y,color,life=1) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()-0.5)*4;
      this.vy = (Math.random()-0.5)*4;
      this.life = life;
      this.color = color;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.life -= 0.02;
    }
    draw() {
      if (this.life > 0) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1;
      }
    }
  }

  class Gem {
    constructor(x,y) {
      this.x = x;
      this.y = y;
      this.collected = false;
    }
    update(player) {
      if (!this.collected &&
          Math.abs(player.x-this.x)<20 &&
          Math.abs(player.y-this.y)<20) {
        this.collected = true;
        if (runtime.effects.gem>0) {
          for (let i=0;i<runtime.effects.gem/4;i++) {
            particles.push(new Particle(this.x,this.y,"yellow",1));
          }
        }
      }
    }
    draw() {
      if (!this.collected) {
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(this.x,this.y,10,0,Math.PI*2);
        ctx.fill();
      }
    }
  }

  let player = new Player();
  let particles = [];
  let gems = [new Gem(400,H-80), new Gem(800,H-120)];
  // world/platform/spike arrays (already declared above as needed)
  let platforms = [];
  let spikes = [];
  let score = 0;
  let bestScore = localStorage.getItem("bestScore") ? parseInt(localStorage.getItem("bestScore")) : 0;
  let lastPlatformX = 0;
  let lastPlatformY = player.y + player.height;

  // generate initial ground platform
  function resetWorld(){
  platforms = [];
  spikes = [];
  gems = [];
  particles = [];
  crashPieces = [];
  trail = [];
  score = 0;
  player = new Player();
  player.visible = true;
  platforms.push({
    x: 0,
    y: H - BLOCK_SIZE * 2,
    width: W,              // span full width
    height: BLOCK_SIZE * 2,
    color: {...platformColor},
    passed:false
  });
  lastPlatformX = W;
  lastPlatformY = H - BLOCK_SIZE * 2;
}


  // more detailed platform generation to match earlier spec
  function generatePlatformsIfNeeded(){
    const lastPlat = platforms[platforms.length - 1];
    if (!lastPlat) return;
    if (lastPlat.x < player.x + W) {
      const out = generateBlockPlatform(lastPlat.x, lastPlat.y);
      lastPlatformX = out.x;
      lastPlatformY = out.y;
    }
  }

  // improved generateBlockPlatform to push blocks & occasional spikes
  function generateBlockPlatform(lastX, lastY){
    let blockCount = Math.floor(Math.random()*8)+1;
    if (Math.random() < 0.7) blockCount = Math.min(blockCount, Math.floor(Math.random()*3+1));
    let gap = Math.floor(Math.random()*5+3) * BLOCK_SIZE;
    let x = lastX + gap;
    let y = lastY + (Math.floor(Math.random()*3)-1) * BLOCK_SIZE;
    y = Math.max(BLOCK_SIZE, Math.min(H - 3*BLOCK_SIZE, y));

    for (let i=0;i<blockCount;i++){
      platforms.push({
        x: x + i*BLOCK_SIZE,
        y: y,
        width: BLOCK_SIZE,
        height: BLOCK_SIZE,
        color: {...platformColor},
        passed: false
      });
      if (Math.random() < 0.2) {
        spikes.push({
          x: x + i*BLOCK_SIZE + BLOCK_SIZE*0.2,
          y: y - BLOCK_SIZE + BLOCK_SIZE*0.2,
          width: BLOCK_SIZE*0.6,
          height: BLOCK_SIZE*0.6,
          baseY: y - BLOCK_SIZE + BLOCK_SIZE*0.2,
          hit: true,
          passed: false
        });
      }
    }

    // gems
    for (let i=0;i<blockCount;i++){
      if (Math.random() < 0.1 || runtime.gemEveryBlock){
        const gemX = x + i*BLOCK_SIZE + BLOCK_SIZE/4;
        const gemY = y - BLOCK_SIZE*1.5;
        let safe = true;
        for (let s of spikes) if (Math.abs(gemX - s.x) < BLOCK_SIZE*2) safe = false;
        if (safe) gems.push({ x: gemX, y: gemY, size: 20, collected: false, floatOffset: Math.random()*Math.PI*2 });
      }
    }

    return { x: x + blockCount * BLOCK_SIZE, y };
  }

  // collisions
  function checkSpikeCollision(sp){
    if (!sp.hit) return false;
    const hbW = player.width * player.hitboxScale;
    const hbH = player.height * player.hitboxScale;
    const hbX = player.x + (player.width - hbW)/2;
    const hbY = player.y + (player.height - hbH)/2;
    return hbX + hbW > sp.x && hbX < sp.x + sp.width && hbY + hbH > sp.y && hbY < sp.y + sp.height;
  }

  // spawn particles helper
  function spawnParticlesAt(x,y,type,amountMul=1){
    // base counts by type
    let base = 12;
    if (type === "double") base = 20;
    if (type === "land") base = 8;
    const count = Math.max(0, Math.floor(base * amountMul));
    const color = type === "double" ? "#ff0" : (type === "jump" ? "#0ff" : "#fff");
    for (let i=0;i<count;i++){
      particles.push(new Particle(x + (Math.random()-0.5)*10, y + (Math.random()-0.5)*10, color, 1));
    }
  }

  // crash pieces array and handling
  let crashPieces = [];
  function createCrashPieces(mult=1){
    const count = Math.max(4, Math.floor(20 * (runtime.effects.dieMul || 0.01) * mult));
    for (let i=0;i<count;i++){
      crashPieces.push({
        x: player.x + Math.random() * player.width,
        y: player.y + Math.random() * player.height,
        vx: (Math.random()-0.5) * 15,
        vy: (Math.random()-1) * 15,
        size: Math.random()*player.width/4 + 4,
        color: player.color,
        life: 40 + Math.random()*60
      });
    }
  }

  // death handling
  function killPlayer(spike){
    if (!player.visible) return;
    if (cheats.invincible) return;
    player.visible = false;
    if (spike) spike.hit = false;
    createCrashPieces();
    gameRunning = false;
    if (score > bestScore) {
      bestScore = Math.floor(score);
      localStorage.setItem("bestScore", bestScore);
    }
    setTimeout(() => {
      document.getElementById("menu").style.display = "flex";
    }, 900);
  }

  // input: jump
  function doJump(){
    if (!player.visible) return;
    if (cheats.infiniteJump || player.jumpsLeft > 0){
      player.vy = JUMP_SPEED;
      spawnParticlesAt(player.x + player.width/2, player.y + player.height, player.jumpsLeft === 2 ? "jump" : "double", runtime.effects.jumpMul || 1);
      if (!cheats.infiniteJump) player.jumpsLeft--;
    }
  }

  // keyboard/touch bindings
  window.addEventListener("keydown", (e) => {
    if (e.code) keys[e.code] = true;
    if (["KeyW","Space","ArrowUp"].includes(e.code)) doJump();
    // console commands
    if (e.ctrlKey && e.shiftKey && e.code === "KeyA"){
      const input = prompt("Enter command:");
      if (!input) return;
      handleCommand(input);
    }
  });
  window.addEventListener("keyup", e => { if (e.code) keys[e.code] = false; });
  window.addEventListener("mousedown", () => doJump());
  window.addEventListener("touchstart", () => doJump());

  // command handler (extended)
  function handleCommand(input){
    const args = input.trim().split(/\s+/);
    const cmd = args[0];
    const a1 = args[1];
    const a2 = args[2];

    if (cmd === "/die"){
      killPlayer();
      return;
    }

    if (cmd === "/score"){
      if (a1 === "set" && a2 !== undefined){
        const v = Number(a2);
        if (!isNaN(v)) score = v; else alert("Invalid value for score set.");
      } else if (a1 === "add" && a2 !== undefined){
        const v = Number(a2);
        if (!isNaN(v)) score += v; else alert("Invalid value for score add.");
      } else alert("Usage: /score set <value> OR /score add <value>");
      return;
    }

    if (cmd === "/clear" && a1 === "bestScore"){
      bestScore = 0;
      localStorage.setItem("bestScore", 0);
      document.getElementById("bestScore") && (document.getElementById("bestScore").innerText = "Best Score: " + bestScore);
      alert("Best score cleared.");
      return;
    }

    // original gamerule/code/variable handlers
    if (cmd === "/gamerule"){
      switch (a1){
        case "infiniteJump": cheats.infiniteJump = (a2 === "true"); break;
        case "death": cheats.invincible = (a2 === "false"); break;
        case "speed":
          if (!player.speedMultiplier) player.speedMultiplier = 1;
          if (a2 === "reset") player.speedMultiplier = 1;
          if (a2 === "add" && !isNaN(parseFloat(a3))) player.speedMultiplier += parseFloat(a3);
          if (a2 === "set" && !isNaN(parseFloat(a3))) player.speedMultiplier = parseFloat(a3);
          break;
        default: alert("Unknown gamerule");
      }
      return;
    }

    if (cmd === "/variable"){
      if (!a1){
        const acct = localStorage.getItem("account") || "player";
        const isCreator = ["bw55133@pausd.us","ikunbeautiful@gmail.com","benranwu@gmail.com"].includes(acct);
        alert("test mode: " + testMode + "\n" +
              "infinite jump: " + cheats.infiniteJump + "\n" +
              "float: " + cheats.float + "\n" +
              "death enabled: " + (!cheats.invincible) + "\n" +
              "score: " + score + "\n" +
              "best score: " + bestScore + "\n" +
              "account: " + (isCreator ? "creator" : "player") + "\n" +
              "player speed: " + player.speed + "\n" +
              "jump height: " + (-JUMP_SPEED));
      }
      return;
    }

    if (cmd === "/code"){
      if (a1 === "770709"){ testMode = !testMode; alert("TEST MODE: " + testMode); }
      else if (a1 === "lanseyaoji"){ player.speed = Math.max(5, player.speed * 1.5); alert("Player speed: " + player.speed); }
      else if (a1 === "jinyumantang"){ runtime.gemEveryBlock = !runtime.gemEveryBlock; alert("Gem every block: " + runtime.gemEveryBlock); }
      else if (a1 === "JiMmYiStHeCoOlEsTgUy|2025.letmecheat|L^UP++0U+L0UD"){
        if (account !== "𐀒𐀒𐀒"){ oldAccount = account; account = "𐀒𐀒𐀒"; } else account = oldAccount || "player";
        alert("Account toggled: " + account);
      }
      return;
    }

    alert("Unknown command or incorrect usage.");
  }

  // update loop continuation: physics, collisions, generation
  function worldStep(delta){
    if (!gameRunning || !player.visible) return;
    // player physics already in Player.update but we can do collision with platforms here
    player.update();

    // platform collisions
    player.onGround = false;
    for (let plat of platforms){
      if (player.x + player.width > plat.x && player.x < plat.x + plat.width &&
          player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy + 2){
        if (player.vy >= 0) {
          player.y = plat.y - player.height;
          player.vy = 0;
          player.onGround = true;
          player.jumpsLeft = 2;
          spawnParticlesAt(player.x + player.width/2, player.y + player.height, "land", runtime.effects.walkMul || 1);
          plat.y += 2;
        }
      }
      if (!plat.passed && player.x > plat.x + plat.width){
        score += 1;
        plat.passed = true;
      }
    }

    // when falling off bottom
    if (player.y > H + 300){
      player.jumpsLeft = 1;
      killPlayer();
    }

    // spikes
    for (let s of spikes){
      if (checkSpikeCollision(s)) killPlayer(s);
      if (!s.passed && player.x > s.x + s.width){
        score += 1;
        s.passed = true;
      }
    }

    // gems
    for (let g of gems){
      if (!g.collected && player.x + player.width > g.x && player.x < g.x + g.size &&
          player.y + player.height > g.y && player.y < g.y + g.size){
        g.collected = true;
        score += 50;
        spawnParticlesAt(g.x + g.size/2, g.y + g.size/2, "double", runtime.effects.gemMul || 1);
      }
    }

    // spawn more
    generatePlatformsIfNeeded();

    // spawn random lines based on lines multiplier
    if (Math.random() < 0.02 * (runtime.effects.linesMul || 1)) addLine();

    // move crash pieces & particles
    for (let i=crashPieces.length-1;i>=0;i--){
      const p = crashPieces[i];
      p.vy += GRAVITY;
      p.x += p.vx; p.y += p.vy;
      p.life--;
      if (p.life <= 0) crashPieces.splice(i,1);
    }

    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.update();
      if (p.life <= 0) particles.splice(i,1);
    }

    // update lines
    for (let i=linesArr.length-1;i>=0;i--){
      const l = linesArr[i];
      l.x -= player.speed * 0.5 * player.horizMultiplier;
      l.life--;
      if (l.x + 50 < 0 || l.life <= 0) linesArr.splice(i,1);
    }
  }
    // --- Part 3 (final) ---

  // line effect storage
  let linesArr = [];
  function addLine(){
    linesArr.push({
      x: W,
      y: Math.random() * H,
      life: 100
    });
  }

  // drawing
  function draw(){
    ctx.clearRect(0,0,W,H);

    // background
    ctx.fillStyle = "#111";
    ctx.fillRect(0,0,W,H);

    // trails
    if (runtime.effects.trailMul > 0){
      ctx.strokeStyle = "rgba(255,255,255,0.3)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i=0;i<trail.length;i++){
        const p = trail[i];
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    // lines
    for (let l of linesArr){
      ctx.strokeStyle = "rgba(0,255,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(l.x, 0);
      ctx.lineTo(l.x, H);
      ctx.stroke();
    }

    // platforms
    for (let plat of platforms){
      if (runtime.blockTexture){
        ctx.fillStyle = "#444";
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
        ctx.strokeStyle = "#888";
        ctx.strokeRect(plat.x, plat.y, plat.width, plat.height);
      } else {
        ctx.fillStyle = "#666";
        ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
      }
    }

    // spikes
    ctx.fillStyle = "#f44";
    for (let s of spikes){
      ctx.beginPath();
      ctx.moveTo(s.x, s.y + s.height);
      ctx.lineTo(s.x + s.width/2, s.y);
      ctx.lineTo(s.x + s.width, s.y + s.height);
      ctx.closePath();
      ctx.fill();
    }

    // gems
    ctx.fillStyle = "#0ff";
    for (let g of gems){
      if (g.collected) continue;
      const offsetY = Math.sin(performance.now()/300 + g.floatOffset) * 5;
      ctx.beginPath();
      ctx.arc(g.x+g.size/2, g.y+g.size/2 + offsetY, g.size/2, 0, Math.PI*2);
      ctx.fill();
    }

    // crash pieces
    for (let p of crashPieces){
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    }

    // particles
    for (let p of particles){
      p.draw(ctx);
    }

    // player
    if (player.visible){
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);
    }

    // HUD
    ctx.fillStyle = "#fff";
    ctx.font = "20px 'Press Start 2P', monospace";
    ctx.fillText("Score: " + Math.floor(score), 20, 40);
    ctx.fillText("Best: " + bestScore, 20, 70);

    // fps/quality label
    ctx.font = "12px 'Press Start 2P', monospace";
    ctx.fillText(runtime.preset + " | FPS: " + fps.toFixed(0), 20, H - 20);
  }

  // loop
  let lastTime = performance.now();
  let fps = 0;
  function loop(){
    const now = performance.now();
    const delta = now - lastTime;
    fps = 1000 / delta;
    lastTime = now;

    if (gameRunning) worldStep(delta);
    draw();
    requestAnimationFrame(loop);
  }
  loop();

  // start game
  function startGame(){
    document.getElementById("menu").style.display = "none";
    resetWorld();
    gameRunning = true;
    player.visible = true;
  }

  // settings navigation
  function openSettings(){
    try {
      fetch("settings.html").then(r=>{
        if (!r.ok) throw new Error();
        window.location.href = "settings.html";
      }).catch(()=>{
        alert("cannot open settings, settings.html required");
      });
    } catch(e){
      alert("cannot open settings, settings.html required");
    }
  }

  // wire buttons
  document.getElementById("startBtn").addEventListener("click", startGame);
  document.getElementById("settingsBtn").addEventListener("click", openSettings);

  // responsive resize
  window.addEventListener("resize", () => {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
  });

  // ensure pixel font applied globally
  document.body.style.fontFamily = "'Press Start 2P', monospace";

  </script>
</body>
</html>
