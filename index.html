<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bridd Jump</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
canvas { display:block; }
#ui { position:absolute; top:0; left:0; width:100%; text-align:center; pointer-events:none; }
#startScreen {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:400px; padding:40px; background:rgba(0,0,0,0.9);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow:0 0 20px #0ff;
    border:3px solid #0ff; border-radius:20px;
}
button { font-size:32px; padding:15px 40px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:12px; transition:0.3s; }
button:hover { color:black; background:#0ff; }
h1 { font-size:60px; margin-bottom:20px; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; animation: glow 1.5s infinite alternate; }
@keyframes glow { 0% { text-shadow:0 0 10px #0ff,0 0 20px #0ff;} 100% {text-shadow:0 0 40px #0ff,0 0 80px #0ff;} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">START</button>
  </div>
</div>

<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const BLOCK_SIZE=50;
const JUMP_SPEED=-15;
const GRAVITY=0.7;

let keys={}, score=0, bestScore=0, lastTime=0, gameStarted=false, shakeIntensity=0, animationId=null;
let platformHue=270; // starting purple

// Player
let player={
    x:100, y:0, width:50, height:50,
    color:"#0ff", vy:0, speed:5, trail:[],
    glow:true, hitboxScale:0.6, jumpsLeft:1
};

// Effects
let platforms=[], spikes=[], particles=[], backgroundParticles=[], whiteLines=[];

// Input
window.addEventListener("keydown", e=>{ if(["KeyW","ArrowUp","Space"].includes(e.code)) jump(); keys[e.code]=true; });
window.addEventListener("keyup", e=>keys[e.code]=false);
window.addEventListener("mousedown", ()=>jump());
window.addEventListener("touchstart", ()=>jump());

// Particle functions
function createExplosion(x,y,color,amount=50){
    for(let i=0;i<amount;i++){
        particles.push({x,y,vx:(Math.random()-0.5)*15,vy:(Math.random()-0.5)*15-2,size:Math.random()*6+2,color,alpha:1,type:"explosion"});
    }
}
function createJumpEffect(x,y,type){
    let color=type==="double"?"#f0f":"#0ff";
    for(let i=0;i<15;i++){
        let angle=Math.random()*Math.PI*2;
        let speed=Math.random()*6+2;
        particles.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,size:Math.random()*6+2,color,alpha:1,type:type});
    }
}
function createLandEffect(x,y){
    for(let i=0;i<20;i++){
        let angle=Math.random()*Math.PI;
        let speed=Math.random()*6+2;
        particles.push({x,y,vx:Math.cos(angle)*speed,vy:-Math.sin(angle)*speed,size:Math.random()*6+2,color:"#0ff",alpha:1,type:"land"});
    }
}

// Jump
function jump(){
    if(player.jumpsLeft>0){
        player.vy=JUMP_SPEED;
        if(player.jumpsLeft===1) createJumpEffect(player.x+player.width/2,player.y+player.height,"single");
        else createJumpEffect(player.x+player.width/2,player.y+player.height,"double");
        player.jumpsLeft--;
    }
}

// Background
function initBackground(){
    backgroundParticles=[];
    for(let i=0;i<200;i++) backgroundParticles.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,size:Math.random()*2+1,alpha:Math.random()*0.5+0.1});
}
function initLines(){
    whiteLines=[];
    for(let i=0;i<50;i++) whiteLines.push({x:canvas.width+Math.random()*500,y:Math.random()*canvas.height,speed:Math.random()*8+2,length:Math.random()*200+50,alpha:Math.random()*0.3+0.1});
}

// Platform generator
function generateBlockPlatform(lastX,lastY){
    let blockCount=Math.floor(Math.random()*5+2);
    let x=lastX+Math.floor(Math.random()*3+2)*BLOCK_SIZE;
    let y=lastY+(Math.floor(Math.random()*3)-1)*BLOCK_SIZE;
    y=Math.max(BLOCK_SIZE,Math.min(canvas.height-3*BLOCK_SIZE,y));
    for(let i=0;i<blockCount;i++){
        platforms.push({x:x+i*BLOCK_SIZE,y,width:BLOCK_SIZE,height:BLOCK_SIZE,color:`hsl(${platformHue},80%,60%)`});
        if(Math.random()<0.1) spikes.push({x:x+i*BLOCK_SIZE+BLOCK_SIZE*0.2,y:y-BLOCK_SIZE+BLOCK_SIZE*0.2,width:BLOCK_SIZE*0.6,height:BLOCK_SIZE*0.6});
    }
    return {x:x+blockCount*BLOCK_SIZE,y};
}

// Reset game
function resetGame(){
    score=0;
    player.x=100; player.y=canvas.height/2-player.height; player.vy=0; player.speed=5; player.trail=[];
    player.jumpsLeft=1;
    platforms=[]; spikes=[]; particles=[];
    initBackground(); initLines();
    platforms.push({x:0,y:player.y+player.height,width:canvas.width,height:BLOCK_SIZE,color:`hsl(${platformHue},80%,60%)`});
    lastPlatform=generateBlockPlatform(canvas.width,player.y);
    lastTime=performance.now();
    if(animationId) cancelAnimationFrame(animationId);
}

// Die
function die(){
    createExplosion(player.x+player.width/2,player.y+player.height/2,"#0ff",150);
    shakeIntensity=15;
    if(score>bestScore) bestScore=Math.floor(score);
    document.getElementById("bestScore").innerText="Best Score: "+bestScore;
    showStartScreen();
    gameStarted=false;
    if(animationId) cancelAnimationFrame(animationId);
}

// UI
function showStartScreen(){document.getElementById("startScreen").style.display="flex";}
function hideStartScreen(){document.getElementById("startScreen").style.display="none";}

// Spike collision
function checkSpikeCollision(spike){
    const hbW=player.width*player.hitboxScale;
    const hbH=player.height*player.hitboxScale;
    const hbX=player.x+(player.width-hbW)/2;
    const hbY=player.y+(player.height-hbH)/2;
    return hbX+hbW>spike.x && hbX<spike.x+spike.width && hbY+hbH>spike.y && hbY<spike.y+spike.height;
}

// Draw curved T-bridge under platforms
function drawBridges(camX){
    for(let plat of platforms){
        ctx.strokeStyle="#0ff"; ctx.lineWidth=3;
        ctx.beginPath();
        let midX=plat.x + plat.width/2 - camX;
        let topY=plat.y+plat.height + 10;
        ctx.moveTo(midX-plat.width/2, topY);
        ctx.quadraticCurveTo(midX, topY+20, midX+plat.width/2, topY);
        ctx.moveTo(midX, topY); ctx.lineTo(midX, topY+20);
        ctx.stroke();
    }
}

// Main loop
function update(time){
    if(!gameStarted) return;
    let delta=(time-lastTime)/1000; lastTime=time;
    let camShakeX=(Math.random()-0.5)*shakeIntensity;
    let camX=player.x-150+camShakeX; if(shakeIntensity>0) shakeIntensity*=0.9;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Update platform hue slowly
    platformHue+=0.05; if(platformHue>360) platformHue=0;

    // White lines
    for(let line of whiteLines){
        ctx.strokeStyle=`rgba(255,255,255,${line.alpha})`; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(line.x,line.y); ctx.lineTo(line.x-line.length,line.y); ctx.stroke();
        line.x-=line.speed; if(line.x+line.length<0) line.x=canvas.width+Math.random()*500;
    }

    // Background
    for(let bp of backgroundParticles){ ctx.fillStyle=`rgba(0,255,255,${bp.alpha})`; ctx.fillRect(bp.x,bp.y,bp.size,bp.size); }

    // Score
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle="#fff"; ctx.font="40px sans-serif"; ctx.fillText(Math.floor(score),20,50); ctx.shadowBlur=0;

    // Player physics
    player.y+=player.vy; player.vy+=GRAVITY;
    player.x+=player.speed; player.speed+=0.00005;

    // Platform collision
    let onGround=false;
    for(let plat of platforms){
        if(player.x+player.width>plat.x && player.x<plat.x+plat.width && player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
            if(!onGround && player.vy>=0) createLandEffect(player.x+player.width/2,player.y+player.height);
            player.y=plat.y-player.height; player.vy=0; onGround=true; player.jumpsLeft=1;
        }
    }
    if(!onGround && player.y>canvas.height) die();

    // Draw platforms
    for(let plat of platforms){
        let grad=ctx.createLinearGradient(plat.x-camX,plat.y,plat.x-camX+plat.width,plat.y);
        grad.addColorStop(0,`hsl(${platformHue},80%,60%)`);
        grad.addColorStop(0.5,`hsl(${(platformHue+20)%360},80%,60%)`);
        grad.addColorStop(1,`hsl(${(platformHue+40)%360},80%,60%)`);
        ctx.fillStyle=grad; ctx.fillRect(plat.x-camX,plat.y,plat.width,plat.height);
    }

    // Draw bridges
    drawBridges(camX);

    // Spikes
    for(let spike of spikes){
        ctx.fillStyle="red"; ctx.beginPath();
        ctx.moveTo(spike.x-camX,spike.y+spike.height); ctx.lineTo(spike.x-camX+spike.width/2,spike.y); ctx.lineTo(spike.x-camX+spike.width,spike.y+spike.height);
        ctx.closePath(); ctx.fill();
        if(checkSpikeCollision(spike)) die();
    }

    // Draw player
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle=player.color; ctx.fillRect(player.x-camX,player.y,player.width,player.height);
    ctx.shadowBlur=0;

    // Generate new platforms
    let last=platforms[platforms.length-1];
    if(last.x<player.x+canvas.width) generateBlockPlatform(last.x,last.y);

    score+=delta*100;
    animationId=requestAnimationFrame(update);
}

// Start button
document.getElementById("startBtn").addEventListener("click", ()=>{
    hideStartScreen(); resetGame();
    gameStarted=true; animationId=requestAnimationFrame(update);
});

showStartScreen();
</script>
</body>
</html>
