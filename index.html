<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bridd Jump</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:#111; }
  #commandOverlay {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    border: 2px solid #0f0;
    padding: 20px;
    z-index: 9999;
    display: none;
  }
  #commandInput {
    width: 400px;
    font-size: 18px;
    padding: 5px;
    background:black;
    color:#0f0;
    border:1px solid #0f0;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<div id="commandOverlay">
  <input type="text" id="commandInput" placeholder="Enter command here...">
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ==== GLOBALS ====
let score = 0;
let scoreFrozen = false;
let globalTime = 0;
let animationFrameId = null;
let gameStarted = false;
let testMode = false;
let freezeGame = false;

// Player
let player = {
    x: 100, y: 200, w: 30, h: 30,
    vy: 0, onGround:false, jumpsLeft:2,
    horizSpeed:8, horizMultiplier:1,
    vertMultiplier:1
};

// Arrays
let platforms = [];
let spikes = [];
let gems = [];
let particles = [];
let crashPieces = [];
let shapes = [];

// Cheats
let cheats = { infiniteJump:false, invincible:false };

// ==== HELPERS ====
function rand(min,max){return Math.random()*(max-min)+min;}
function randInt(min,max){return Math.floor(rand(min,max));}

// ==== PLATFORM GENERATION ====
function generatePlatforms(){
    let y = 400;
    for(let i=0;i<20;i++){
        let w = randInt(60,200);
        let x = i*200;
        platforms.push({x,y,w,h:20,pressed:0,passed:false});
        if(Math.random()<0.3){
            spikes.push({x:x+randInt(0,w-20),y:y-20,w:20,h:20});
        }
        if(Math.random()<0.2){
            gems.push({x:x+randInt(0,w-20),y:y-randInt(20,80),size:15,collected:false});
        }
    }
}

// ==== INPUT ====
window.addEventListener("keydown",e=>{
    if(e.code==="Space"||e.code==="ArrowUp"){
        if(player.onGround||player.jumpsLeft>0||cheats.infiniteJump){
            player.vy=-12*player.vertMultiplier;
            if(!player.onGround) player.jumpsLeft--;
        }
    }
    if(testMode){
        if(e.code==="KeyG") cheats.float=!cheats.float;
        if(e.code==="KeyJ") cheats.infiniteJump=!cheats.infiniteJump;
        if(e.code==="KeyQ") player.horizMultiplier=Math.max(0.5,player.horizMultiplier-0.2);
        if(e.code==="KeyE") player.horizMultiplier+=0.2;
        if(e.code==="Digit0"){player.horizMultiplier=1;player.vertMultiplier=1;}
        if(e.code==="Digit1") player.vertMultiplier+=0.2;
        if(e.code==="Digit2") player.vertMultiplier=Math.max(0.5,player.vertMultiplier-0.2);
    }
});

// ==== UPDATE ====
function updateGame(delta){
    if(freezeGame) return;

    globalTime+=delta;

    // Horizontal speed growth
    player.x += player.horizSpeed*player.horizMultiplier*delta;

    // Gravity
    if(!cheats.float) player.vy+=25*delta*player.vertMultiplier;
    player.y+=player.vy;

    player.onGround=false;

    // Platform collision
    platforms.forEach(p=>{
        if(player.x+player.w>p.x&&player.x<p.x+p.w){
            if(player.y+player.h>=p.y-p.pressed&&player.y+player.h<=p.y+p.h){
                player.y=p.y-p.h;
                player.vy=0;
                player.onGround=true;
                player.jumpsLeft=2;
                p.pressed=5;
                if(!p.passed){score++;p.passed=true;}
            }
        }
        if(p.pressed>0) p.pressed-=delta*30;
    });

    // Spike collision
    if(!cheats.invincible){
        spikes.forEach(s=>{
            if(player.x< s.x+s.w && player.x+player.w> s.x &&
               player.y< s.y+s.h && player.y+player.h> s.y){
                createCrash();
            }
        });
    }

    // Gems
    gems.forEach(g=>{
        if(!g.collected && player.x<g.x+g.size && player.x+player.w>g.x &&
           player.y<g.y+g.size && player.y+player.h>g.y){
            g.collected=true;
            score+=50;
            spawnParticles(g.x,g.y,"#fff",40,12,true);
        }
    });

    // Update particles
    particles=particles.filter(p=>p.life>0);
    particles.forEach(p=>{
        p.x+=p.vx;p.y+=p.vy;p.life--;
    });

    // Crash pieces
    crashPieces=crashPieces.filter(c=>c.life>0);
    crashPieces.forEach(c=>{c.x+=c.vx;c.y+=c.vy;c.life--;});
}

// ==== PARTICLES ====
function spawnParticles(x,y,color,count,size,glow){
    for(let i=0;i<count;i++){
        particles.push({
            x,y,
            vx:rand(-2,2),vy:rand(-2,2),
            life:30,
            size:size||4,
            color:color,
            glow:glow?30:10
        });
    }
}

// ==== CRASH ====
function createCrash(){
    for(let i=0;i<20;i++){
        crashPieces.push({
            x:player.x,y:player.y,
            vx:rand(-5,5),vy:rand(-5,5),
            size:rand(4,10),color:"#0ff",life:60,glow:20
        });
    }
    player.x=100;player.y=200;player.vy=0;
    player.horizMultiplier=1;score=0;
}

// ==== DRAW ====
function drawGame(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    let camX=player.x-canvas.width/3;
    let camY=player.y-canvas.height/2+50;

    // Platforms
    platforms.forEach(p=>{
        ctx.fillStyle="#0ff";
        ctx.shadowColor="#0ff";ctx.shadowBlur=20;
        ctx.fillRect(p.x-camX,p.y-camY,p.w,p.h);
        ctx.shadowBlur=0;
    });

    // Spikes
    spikes.forEach(s=>{
        ctx.fillStyle="red";
        ctx.beginPath();
        ctx.moveTo(s.x-camX,s.y-camY+s.h);
        ctx.lineTo(s.x+s.w/2-camX,s.y-camY);
        ctx.lineTo(s.x+s.w-camX,s.y-camY+s.h);
        ctx.closePath();ctx.fill();
    });

    // Gems
    gems.forEach(g=>{
        if(!g.collected){
            ctx.save();
            ctx.translate(g.x+g.size/2-camX,g.y+g.size/2-camY);
            ctx.rotate(globalTime);
            ctx.fillStyle="#fff";
            ctx.shadowColor="#fff";ctx.shadowBlur=25;
            ctx.fillRect(-g.size/2,-g.size/2,g.size,g.size);
            ctx.restore();
        }
    });

    // Player
    ctx.fillStyle="#0ff";
    ctx.shadowColor="#0ff";ctx.shadowBlur=20;
    ctx.fillRect(player.x-camX,player.y-camY,player.w,player.h);
    ctx.shadowBlur=0;

    // Particles
    particles.forEach(p=>{
        ctx.fillStyle=p.color;
        ctx.shadowColor=p.color;ctx.shadowBlur=p.glow;
        ctx.fillRect(p.x-camX,p.y-camY,p.size,p.size);
    });

    // Crash pieces
    crashPieces.forEach(c=>{
        ctx.fillStyle=c.color;
        ctx.shadowColor=c.color;ctx.shadowBlur=c.glow;
        ctx.fillRect(c.x-camX,c.y-camY,c.size,c.size);
    });

    // Score
    ctx.fillStyle="#fff";
    ctx.font="30px sans-serif";
    ctx.fillText("Score: "+Math.floor(score),20,40);
}

// ==== LOOP ====
let lastTime=0;
function gameLoop(timestamp){
    let delta=(timestamp-lastTime)/1000;lastTime=timestamp;
    updateGame(delta);
    drawGame();
    animationFrameId=requestAnimationFrame(gameLoop);
}

// ==== COMMAND SYSTEM ====
const commandOverlay=document.getElementById("commandOverlay");
const commandInput=document.getElementById("commandInput");

window.addEventListener("keydown",e=>{
    if(e.ctrlKey&&e.shiftKey&&e.code==="KeyA"){
        e.preventDefault();
        commandOverlay.style.display="block";
        commandInput.focus();
    }
});

commandInput.addEventListener("keydown",e=>{
    if(e.key==="Enter"){
        handleCommand(commandInput.value);
        commandInput.value="";
        commandOverlay.style.display="none";
    }
});

function handleCommand(cmd){
    const parts=cmd.trim().split(/\s+/);
    if(parts.length===0)return;
    const command=parts[0];
    const roots=parts.slice(1);

    if(command==="gamerule"){
        switch(roots[0]){
            case"infiniteJump":cheats.infiniteJump=roots[1]==="true";break;
            case"death":cheats.invincible=roots[1]==="false";break;
            case"speed":
                let n=parseFloat(roots[2]||1);
                if(roots[1]==="reset")n=1;
                else if(roots[1]==="add")n+=player.horizMultiplier;
                if(roots[3]==="horizontal")player.horizMultiplier=n;
                else if(roots[3]==="vertical"||roots[3]==="verticle")player.vertMultiplier=n;
                else player.horizMultiplier=player.vertMultiplier=n;
                break;
            case"score":
                if(roots[1]==="reset")score=0;
                if(roots[1]==="freeze")scoreFrozen=true;
                if(roots[1]==="unfreeze")scoreFrozen=false;
                if(roots[1]==="add")score+=parseFloat(roots[2]||0);
                if(roots[1]==="set")score=parseFloat(roots[2]||0);
                break;
        }
    }else if(command==="control"){
        if(roots[0]==="freeze")freezeGame=true;
        if(roots[0]==="unfreeze")freezeGame=false;
    }else if(command==="code"){
        if(roots[0]==="770709")testMode=true;
        if(roots[0]==="lanseyaoji")player.horizMultiplier=10;
    }
}

// ==== START ====
function startGame(){generatePlatforms();requestAnimationFrame(gameLoop);}
startGame();
</script>
</body>
</html>
