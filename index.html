<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Schedule | Infinite Campus</title>
<link rel="icon" type="image/png" href="infinite-campus-icon.png">

<!-- Pixel font from Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000;
    --accent:#0ff;
    --panel:rgba(0,0,0,0.9);
    --muted:#88f7ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:"Press Start 2P",monospace,system-ui; -webkit-font-smoothing:none; -moz-osx-font-smoothing:grayscale;}
  canvas{display:block;width:100%;height:100%;}
  #ui{position:fixed;inset:0;pointer-events:none;z-index:200}
  #startScreen{
    position:fixed; left:50%; top:50%; transform:translate(-50%,-50%);
    width:500px; max-width:94vw; padding:28px; background:var(--panel);
    border:4px solid var(--accent); border-radius:14px; display:flex; flex-direction:column; align-items:center; gap:12px; pointer-events:all;
  }
  h1{margin:0;font-size:34px;color:var(--accent);text-shadow:0 0 16px var(--accent);}
  #bestScore{font-size:12px;color:var(--muted); margin-top:4px;}
  .btn{appearance:none;border:3px solid var(--accent); background:transparent; color:var(--accent); padding:12px 18px; border-radius:10px; font-size:12px; cursor:pointer; transition:all .12s; font-family:"Press Start 2P",monospace;}
  .btn:hover{background:var(--accent); color:#000;}
  #startBtn{width:260px}
  #settingsBtn{width:260px}
  #scoreOverlay{position:fixed;left:16px;top:16px;font-size:12px;pointer-events:none;z-index:210}
  #settingsLabel{position:fixed; right:16px; top:84px; color:var(--accent); font-size:11px; text-shadow:0 0 8px var(--accent); pointer-events:none; z-index:210}
  @media (max-width:540px){
    #startScreen{width:92vw;padding:18px}
    h1{font-size:26px}
    .btn{font-size:10px;padding:10px}
  }
  /* small helper styles for debug text */
  #debugToast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:rgba(0,0,0,0.6);border:2px solid var(--accent);color:var(--accent);padding:6px 12px;border-radius:10px;font-size:11px;pointer-events:none;z-index:300;display:none;}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="ui">
  <div id="startScreen">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn" class="btn">START</button>
    
  </div>
</div>

<div id="scoreOverlay">0</div>
<div id="settingsLabel"></div>
<div id="debugToast"></div>

<script>
/* ----------------------------------------------------------------------
   Bridd Jump: index.html (full expanded)
   - Gameplay: platforms, spikes, gems, particles, crash, trail, camera
   - Commands: /die, /score, /clear bestScore, /gamerule, /variable, /code
   - Settings: reads from localStorage key "briddSettings"
   - Start screen contains START and SETTINGS (navigates to settings.html)
   - Pixel font used site-wide
   ---------------------------------------------------------------------- */

/* -------------------------
   Canvas setup & resize
   ------------------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/* -------------------------
   Constants & defaults
   ------------------------- */
const BLOCK_SIZE = 50;
const JUMP_SPEED = -15;
const GRAVITY = 0.7;

/* -------------------------
   Game variables
   ------------------------- */
let keys = {};
let score = 0;
let bestScore = localStorage.getItem('bestScore') ? parseInt(localStorage.getItem('bestScore')) : 0;
let lastTime = 0;
let gameStarted = false;
let animationFrameId = null;
let crashPieces = [], particles = [], gems = [], trail = [];
let spikes = [], platforms = [], lines = [];
let startPressCount = 0;

let testMode = false;
let gemEveryBlock = false;
let account = "player";
let oldAccount = null;
let cheats = { float:false, invincible:false, infiniteJump:false };

/* colors for platforms cycling */
let baseColors = [
  {r:255,g:0,b:0},
  {r:255,g:153,b:0},
  {r:255,g:255,b:0},
  {r:0,g:255,b:0},
  {r:0,g:255,b:255},
  {r:0,g:0,b:255},
  {r:153,g:0,b:255}
];
let colorIndex = 0;
let platformColor = {...baseColors[0]};
let nextColor = baseColors[1];
let colorLerp = 0;
let globalTime = 0;

/* player object */
let player = {
  x:100, y:0, width:50, height:50, vy:0, speed:8, color:"#0ff",
  hitboxScale:0.6, jumpsLeft:2, onGround:false, visible:true,
  horizMultiplier:1, vertMultiplier:1, accountEmail:"player@example.com"
};

/* -------------------------
   SETTINGS system (localStorage)
   settings.html will write here; index.html reads and applies
   ------------------------- */

const LS_KEY = "briddSettings";

const defaultSettings = {
  maxFPS: 0, // 0 -> unlimited
  qualityPreset: "Extreme+",
  quality: {
    jumpEffect: 64,
    walkEffect: 64,
    dieEffect: 64,
    horizontalLines: 64,
    trail: 64,
    blockTexture: 100
  }
};

const qualityPresets = {
  "Potato":      { blockTexture:0, jumpEffect:0, walkEffect:0, dieEffect:0, horizontalLines:0, trail:0, glow:false, lines:false },
  "Low":         { blockTexture:0, jumpEffect:5, walkEffect:0, dieEffect:0, horizontalLines:0, trail:0, glow:false, lines:false },
  "Medium":      { blockTexture:1, jumpEffect:10, walkEffect:0, dieEffect:10, horizontalLines:0, trail:0, glow:false, lines:false },
  "Medium+":     { blockTexture:1, jumpEffect:15, walkEffect:15, dieEffect:15, horizontalLines:0, trail:0, glow:false, lines:false },
  "High":        { blockTexture:1, jumpEffect:15, walkEffect:15, dieEffect:15, horizontalLines:15, trail:0, glow:true, lines:true },
  "High+":       { blockTexture:1, jumpEffect:33, walkEffect:33, dieEffect:33, horizontalLines:33, trail:0, glow:true, lines:true },
  "Extreme":     { blockTexture:1, jumpEffect:60, walkEffect:60, dieEffect:60, horizontalLines:60, trail:0, glow:true, lines:true },
  "Extreme+":    { blockTexture:1, jumpEffect:64, walkEffect:64, dieEffect:64, horizontalLines:64, trail:1, glow:true, lines:true },
  "Ultra":       { blockTexture:1, jumpEffect:100, walkEffect:100, dieEffect:100, horizontalLines:100, trail:0, glow:true, lines:true },
  "Ultra+":      { blockTexture:1, jumpEffect:120, walkEffect:120, dieEffect:120, horizontalLines:120, trail:1, glow:true, lines:true },
  "Glow Highest":{ blockTexture:1, jumpEffect:200, walkEffect:200, dieEffect:200, horizontalLines:200, trail:1, glow:true, lines:true }
};

function readSettings(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return JSON.parse(JSON.stringify(defaultSettings));
    const parsed = JSON.parse(raw);
    const merged = JSON.parse(JSON.stringify(defaultSettings));
    if(parsed.maxFPS !== undefined) merged.maxFPS = parsed.maxFPS;
    if(parsed.qualityPreset) merged.qualityPreset = parsed.qualityPreset;
    if(parsed.quality) merged.quality = {...merged.quality, ...parsed.quality};
    return merged;
  }catch(e){
    console.warn("Failed to read settings, using defaults", e);
    return JSON.parse(JSON.stringify(defaultSettings));
  }
}
function writeSettings(s){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(s)); } catch(e){ console.warn("Failed to write settings", e); }
}

let settings = readSettings();

/* runtime derived parameters */
let runtime = {
  minFrameTime: 0, // ms between frames (0 => unlimited)
  effects: {
    jumpEffectMul: 1,
    walkEffectMul: 1,
    dieEffectMul: 1,
    horizontalLinesMul: 1,
    trailMul: 1,
    blockTextureMul: 1
  },
  glowEnabled: true,
  linesEnabled: true,
  trailEnabled: true
};

function applySettings(s){
  settings = s || settings;
  // FPS
  if(!settings.maxFPS || settings.maxFPS === 0 || settings.maxFPS === "Unlimited"){
    runtime.minFrameTime = 0;
    settings.maxFPS = 0;
  } else {
    runtime.minFrameTime = 1000 / Number(settings.maxFPS);
  }
  // preset
  const preset = qualityPresets[settings.qualityPreset] || {};
  const pct = (v) => (Number(v) || 0) / 100;
  runtime.effects.blockTextureMul = pct(settings.quality.blockTexture) || (preset.blockTexture ? 1 : 0);
  runtime.effects.jumpEffectMul = pct(settings.quality.jumpEffect) || (preset.jumpEffect ? preset.jumpEffect/100 : 0);
  runtime.effects.walkEffectMul = pct(settings.quality.walkEffect) || (preset.walkEffect ? preset.walkEffect/100 : 0);
  runtime.effects.dieEffectMul = pct(settings.quality.dieEffect) || (preset.dieEffect ? preset.dieEffect/100 : 0);
  runtime.effects.horizontalLinesMul = pct(settings.quality.horizontalLines) || (preset.horizontalLines ? preset.horizontalLines/100 : 0);
  runtime.effects.trailMul = pct(settings.quality.trail) || (preset.trail ? preset.trail/100 : 0);
  runtime.glowEnabled = preset.glow !== undefined ? preset.glow : true;
  runtime.linesEnabled = preset.lines !== undefined ? preset.lines : true;
  runtime.trailEnabled = settings.quality.trail > 0 || preset.trail;
  // Save canonical settings back
  writeSettings(settings);
  document.getElementById('settingsLabel').innerText = settings.maxFPS === 0 ? `FPS: Unlimited â€” Quality: ${settings.qualityPreset}` : `FPS: ${settings.maxFPS} â€” Quality: ${settings.qualityPreset}`;
}

/* apply on load */
applySettings(settings);

/* -------------------------
   Input handlers
   ------------------------- */
window.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if(["KeyW","ArrowUp","Space"].includes(e.code)) jump();
});
window.addEventListener('keyup', (e) => { keys[e.code] = false; });
window.addEventListener('mousedown', () => jump());
window.addEventListener('touchstart', () => jump());

function jump(){
  if(!player.visible) return;
  if(cheats.infiniteJump || player.jumpsLeft > 0){
    player.vy = JUMP_SPEED;
    spawnParticles(player.x + player.width/2, player.y + player.height, player.jumpsLeft===2 ? "jump" : "double", runtime.effects.jumpEffectMul);
    if(!cheats.infiniteJump) player.jumpsLeft--;
  }
}

/* -------------------------
   World generation: platforms, spikes, gems
   ------------------------- */
function generateBlockPlatform(lastX, lastY){
  let blockCount = Math.floor(Math.random()*8)+1;
  if(Math.random()<0.7) blockCount = Math.min(blockCount, Math.floor(Math.random()*3+1));

  let gap = Math.floor(Math.random()*5+3) * BLOCK_SIZE;
  let x = lastX + gap;
  let y = lastY + (Math.floor(Math.random()*3) - 1) * BLOCK_SIZE;
  y = Math.max(BLOCK_SIZE, Math.min(canvas.height - 3*BLOCK_SIZE, y));

  for(let i=0;i<blockCount;i++){
    platforms.push({
      x: x + i*BLOCK_SIZE,
      y,
      width: BLOCK_SIZE,
      height: BLOCK_SIZE,
      color: {...platformColor},
      passed: false
    });

    if(Math.random() < 0.2){
      spikes.push({
        x: x + i*BLOCK_SIZE + BLOCK_SIZE*0.2,
        y: y - BLOCK_SIZE + BLOCK_SIZE*0.2,
        width: BLOCK_SIZE*0.6,
        height: BLOCK_SIZE*0.6,
        baseY: y - BLOCK_SIZE + BLOCK_SIZE*0.2,
        hit: true,
        passed: false
      });
    }
  }

  // gems
  for(let i=0;i<blockCount;i++){
    if(Math.random() < 0.1 || gemEveryBlock){
      let gemX = x + i*BLOCK_SIZE + BLOCK_SIZE/4;
      let gemY = y - BLOCK_SIZE*1.5;
      let safe = true;
      for(let s of spikes) if(Math.abs(gemX - s.x) < BLOCK_SIZE*2) safe = false;
      if(safe) gems.push({ x: gemX, y: gemY, size: 20, collected: false, floatOffset: Math.random()*Math.PI*2 });
    }
  }

  return { x: x + blockCount*BLOCK_SIZE, y };
}

/* -------------------------
   Collision & helpers
   ------------------------- */
function checkSpikeCollision(spike){
  if(!spike.hit) return false;
  const hbW = player.width * player.hitboxScale;
  const hbH = player.height * player.hitboxScale;
  const hbX = player.x + (player.width - hbW)/2;
  const hbY = player.y + (player.height - hbH)/2;
  return hbX + hbW > spike.x && hbX < spike.x + spike.width && hbY + hbH > spike.y && hbY < spike.y + spike.height;
}

function createCrash(multiplier = 1){
  const pieces = Math.max(4, Math.floor(20 * (runtime.effects.dieEffectMul || multiplier)));
  for(let i=0;i<pieces;i++){
    crashPieces.push({
      x: player.x + Math.random()*player.width,
      y: player.y + Math.random()*player.height,
      vx: (Math.random()-0.5)*15,
      vy: (Math.random()-1)*15,
      size: Math.random()*player.width/4 + 5,
      color: player.color
    });
  }
}

function spawnParticles(x, y, type, amountMul = 1){
  const base = 15;
  const count = Math.max(0, Math.floor(base * (amountMul || runtime.effects.jumpEffectMul || 1)));
  const color = type === "jump" ? "#0ff" : type === "double" ? "#ff0" : "#fff";
  for(let i=0;i<count;i++){
    particles.push({ x, y, vx:(Math.random()-0.5)*5, vy:(Math.random()-1.5)*5, life: Math.random()*30 + 20, color });
  }
}

function tryDie(spike){
  if(!player.visible) return;
  if(cheats.invincible) return;
  if(player.onGround || player.vy > 0){
    player.visible = false;
    if(spike) spike.hit = false;
    createCrash();
    gameStarted = false;
    if(score > bestScore){
      bestScore = Math.floor(score);
      localStorage.setItem('bestScore', bestScore);
    }
    setTimeout(()=> showStartScreen(), 1000);
  }
}

/* -------------------------
   Lines background spawn
   ------------------------- */
function addLine(){
  if(!runtime.linesEnabled) return;
  const chance = Math.min(1, 0.15 * (runtime.effects.horizontalLinesMul || 0));
  if(Math.random() > chance) return;
  lines.push({ x: canvas.width, y: Math.random()*canvas.height, width: Math.random()*50 + 20 });
}

/* lerp helper */
function lerpColor(c1, c2, t){ return { r: c1.r + (c2.r - c1.r)*t, g: c1.g + (c2.g - c1.g)*t, b: c1.b + (c2.b - c1.b)*t }; }

/* -------------------------
   Camera & FPS limiter vars
   ------------------------- */
let cameraX = 0, cameraY = 0;
let lastRenderTime = performance.now();

/* -------------------------
   Main update & draw loop
   ------------------------- */
function update(time){
  animationFrameId = requestAnimationFrame(update);
  if(!time) time = performance.now();

  // FPS limiter
  if(runtime.minFrameTime > 0){
    const since = time - lastRenderTime;
    if(since < runtime.minFrameTime) return;
    lastRenderTime = time;
  } else {
    lastRenderTime = time;
  }

  const delta = (time - lastTime)/1000 || 0;
  lastTime = time;
  globalTime += delta;

  if(gameStarted && player.visible){
    // slowly accelerate
    player.speed += 0.002;

    // color cycling
    colorLerp += delta/25;
    if(colorLerp >= 1){
      colorIndex = (colorIndex + 1) % baseColors.length;
      nextColor = baseColors[(colorIndex+1) % baseColors.length];
      colorLerp = 0;
    }
    platformColor = lerpColor(baseColors[colorIndex], nextColor, colorLerp);

    // physics
    player.y += player.vy * player.vertMultiplier;
    if(cheats.float && player.vy > 0) player.vy *= 0.5;
    player.vy += GRAVITY * player.vertMultiplier;
    player.x += player.speed * player.horizMultiplier;

    // collisions with platforms
    player.onGround = false;
    for(let plat of platforms){
      if(player.x + player.width > plat.x && player.x < plat.x + plat.width &&
         player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy){
        if(player.vy >= 0){
          player.y = plat.y - player.height;
          player.vy = 0;
          player.onGround = true;
          player.jumpsLeft = 2;
          spawnParticles(player.x + player.width/2, player.y + player.height, "land", runtime.effects.walkEffectMul);
          // subtle sink
          plat.y += 2;
        }
      }
      if(!plat.passed && player.x > plat.x + plat.width){ score += 1; plat.passed = true; }
    }
    if(player.y > canvas.height){ player.jumpsLeft = 1; tryDie(); }

    // spikes
    for(let spike of spikes){
      if(checkSpikeCollision(spike)) tryDie(spike);
      if(!spike.passed && player.x > spike.x + spike.width){ score += 1; spike.passed = true; }
    }

    // gems
    for(let g of gems){
      if(!g.collected && player.x + player.width > g.x && player.x < g.x + g.size && player.y + player.height > g.y && player.y < g.y + g.size){
        score += 50;
        g.collected = true;
        spawnParticles(g.x + g.size/2, g.y + g.size/2, "double", runtime.effects.jumpEffectMul);
      }
    }

    // extend world
    const lastPlatform = platforms[platforms.length - 1];
    if(lastPlatform && lastPlatform.x < player.x + canvas.width) generateBlockPlatform(lastPlatform.x, lastPlatform.y);

    addLine();
  }

  // smooth camera
  const targetCamX = player.x - 150;
  const targetCamY = player.y - canvas.height/2 + player.height*1.5;
  cameraX = cameraX*0.9 + targetCamX*0.1;
  cameraY = cameraY*0.9 + targetCamY*0.1;

  // draw all
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // update HUD
  document.getElementById('scoreOverlay').innerText = Math.floor(score);

  // draw platforms
  for(let plat of platforms){
    let glow = Math.sin(globalTime*3) * 10 + 15;
    const useTexture = runtime.effects.blockTextureMul > 0.5;
    if(useTexture){
      for(let y = plat.y; y < canvas.height; y += BLOCK_SIZE){
        let darkFactor = y === plat.y ? 1 : 0.3;
        const grd = ctx.createLinearGradient(plat.x - cameraX, y - cameraY, plat.x + plat.width - cameraX, y + BLOCK_SIZE - cameraY);
        grd.addColorStop(0, `rgba(${Math.floor(plat.color.r * darkFactor)},${Math.floor(plat.color.g * darkFactor)},${Math.floor(plat.color.b * darkFactor)},1)`);
        grd.addColorStop(1, "rgba(0,0,0,1)");
        ctx.fillStyle = grd;
        if(runtime.glowEnabled) { ctx.shadowColor = `rgba(${plat.color.r},${plat.color.g},${plat.color.b},0.9)`; ctx.shadowBlur = plat === platforms[0] ? glow : 0; }
        ctx.fillRect(plat.x - cameraX, y - cameraY, plat.width, BLOCK_SIZE);
        ctx.shadowBlur = 0;
      }
    } else {
      ctx.fillStyle = `rgb(${plat.color.r},${plat.color.g},${plat.color.b})`;
      ctx.fillRect(plat.x - cameraX, plat.y - cameraY, plat.width, plat.height);
    }
  }

  // draw spikes
  for(let spike of spikes){
    let pulse = Math.sin(globalTime*5 + spike.x) * 5;
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(spike.x - cameraX, spike.baseY + spike.height - cameraY + pulse);
    ctx.lineTo(spike.x - cameraX + spike.width/2, spike.baseY - cameraY + pulse);
    ctx.lineTo(spike.x - cameraX + spike.width, spike.baseY + spike.height - cameraY + pulse);
    ctx.closePath();
    ctx.fill();
  }

  // draw gems
  for(let g of gems){
    if(g.collected) continue;
    g.floatOffset = g.floatOffset || Math.random()*Math.PI*2;
    let floatY = Math.sin(globalTime*3 + g.floatOffset) * 5;
    ctx.save();
    ctx.translate(g.x + g.size/2 - cameraX, g.y + g.size/2 - cameraY + floatY);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle = "white";
    if(runtime.glowEnabled){ ctx.shadowColor = "white"; ctx.shadowBlur = 20 + 10*Math.sin(globalTime*5); }
    ctx.fillRect(-g.size/2, -g.size/2, g.size, g.size);
    ctx.restore();
    ctx.shadowBlur = 0;
  }

  // draw trail (clones)
  if(player.visible && runtime.trailEnabled){
    if(trail.length === 0 || Math.hypot(player.x - trail[trail.length-1].x, player.y - trail[trail.length-1].y) > 15){
      trail.push({ x: player.x, y: player.y, width: player.width, height: player.height, color: player.color });
    }
    const maxTrailLen = Math.max(10, Math.floor(50 * (runtime.effects.trailMul || 1)));
    if(trail.length > maxTrailLen) trail.shift();
    for(let i=0;i<trail.length;i++){
      const t = trail[i];
      ctx.save();
      let alpha = (i+1) / trail.length;
      ctx.globalAlpha = alpha * 0.6;
      if(runtime.glowEnabled) { ctx.shadowColor = t.color; ctx.shadowBlur = 15 * alpha; }
      ctx.fillStyle = t.color;
      ctx.fillRect(t.x - cameraX, t.y - cameraY, t.width, t.height);
      ctx.strokeStyle = t.color; ctx.lineWidth = 4; ctx.strokeRect(t.x - cameraX, t.y - cameraY, t.width, t.height);
      ctx.restore();
    }
    ctx.globalAlpha = 1;
  } else {
    trail = [];
  }

  // draw player
  if(player.visible){
    if(runtime.glowEnabled){ ctx.shadowColor = "#0ff"; ctx.shadowBlur = 20; }
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - cameraX, player.y - cameraY, player.width, player.height);
    if(runtime.glowEnabled) ctx.shadowBlur = 0;
    ctx.strokeStyle = "#0ff"; ctx.lineWidth = 6; ctx.strokeRect(player.x - cameraX, player.y - cameraY, player.width, player.height);
  }

  // crash pieces
  for(let i=crashPieces.length-1;i>=0;i--){
    const p = crashPieces[i];
    p.vy += GRAVITY;
    p.x += p.vx; p.y += p.vy;
    ctx.fillStyle = p.color; ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size);
    if(p.y - cameraY > canvas.height + 400) crashPieces.splice(i,1);
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life > 0){ ctx.fillStyle = p.color; ctx.fillRect(p.x - cameraX, p.y - cameraY, 5, 5); } else particles.splice(i,1);
  }

  // horizontal lines
  for(let i=lines.length-1;i>=0;i--){
    const l = lines[i];
    l.x -= player.speed * 0.5 * player.horizMultiplier;
    if(runtime.linesEnabled){
      ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(l.x - cameraX, l.y - cameraY); ctx.lineTo(l.x + 50 - cameraX, l.y - cameraY); ctx.stroke();
    }
    if(l.x + 50 < 0) lines.splice(i,1);
  }
}

/* -------------------------
   UI: Start / Settings
   ------------------------- */
document.getElementById('startBtn').addEventListener('click', () => {
  resetGame();
});
document.getElementById('settingsBtn').addEventListener('click', () => {
  // replace page with settings.html (user requested navigation)
  window.location.href = 'settings.html';
});

/* show/hide start screen */
function showStartScreen(){
  document.getElementById('bestScore').innerText = 'Best Score: ' + bestScore;
  document.getElementById('startScreen').style.display = 'flex';
}
function hideStartScreen(){ document.getElementById('startScreen').style.display = 'none'; }

/* reset game */
function resetGame(){
  if(animationFrameId) cancelAnimationFrame(animationFrameId);
  startPressCount++;
  score = 0; colorLerp = 0; globalTime = 0; trail = [];
  player.x = 100; player.y = canvas.height/2 - player.height; player.vy = 0; player.speed = 8;
  player.jumpsLeft = 2; player.onGround = false; player.visible = true;
  player.horizMultiplier = 1; player.vertMultiplier = 1;
  platforms = []; spikes = []; crashPieces = []; particles = []; gems = []; lines = [];
  platformColor = {...baseColors[0]}; colorIndex = 0; nextColor = baseColors[1];
  platforms.push({ x:0, y: player.y + player.height, width: BLOCK_SIZE*10, height: BLOCK_SIZE, color:{...platformColor}, passed:false });
  lastTime = performance.now();
  hideStartScreen();
  gameStarted = true;
  animationFrameId = requestAnimationFrame(update);
}

/* -------------------------
   Console commands Ctrl+Shift+A
   ------------------------- */
window.addEventListener('keydown', (e) => {
  if(e.ctrlKey && e.shiftKey && e.code === 'KeyA'){
    const input = prompt('Enter command:');
    if(!input) return;
    const args = input.trim().split(/\s+/);
    const command = args[0];
    const root1 = args[1];
    const root2 = args[2];
    const root3 = args[3];
    // gamerule
    if(command === '/gamerule'){
      switch(root1){
        case 'infiniteJump': cheats.infiniteJump = (root2 === 'true'); break;
        case 'death': cheats.invincible = (root2 === 'false'); break;
        case 'speed':
          if(!player.speedMultiplier) player.speedMultiplier = 1;
          if(root2 === 'reset') player.speedMultiplier = 1;
          if(root2 === 'add' && !isNaN(parseFloat(root3))) player.speedMultiplier += parseFloat(root3);
          if(root2 === 'set' && !isNaN(parseFloat(root3))) player.speedMultiplier = parseFloat(root3);
          // optional third arg to specify axis
          if(root3){
            switch(root3.toLowerCase()){
              case 'horizontal': player.horizMultiplier = player.speedMultiplier; break;
              case 'vertical': player.vertMultiplier = player.speedMultiplier; break;
              case 'both': player.horizMultiplier = player.vertMultiplier = player.speedMultiplier; break;
            }
          } else player.horizMultiplier = player.vertMultiplier = player.speedMultiplier;
          break;
      }
    }

    // variable
    if(command === '/variable'){
      if(!root1){
        let accountLocal = localStorage.getItem('account') || 'player';
        let isCreator = ['bw55133@pausd.us','ikunbeautiful@gmail.com','benranwu@gmail.com'].includes(accountLocal);
        alert(
          'test mode: '+testMode+'\n'+
          'infinite jump: '+cheats.infiniteJump+'\n'+
          'float: '+cheats.float+'\n'+
          'death enabled: '+(!cheats.invincible)+'\n'+
          'score: '+score+'\n'+
          'best score: '+bestScore+'\n'+
          'account: '+(isCreator?'creator':'player')+'\n'+
          'player speed: '+player.speed+'\n'+
          'jump height: '+(-JUMP_SPEED)
        );
      }
    }

    // code
    if(command === '/code'){
      if(root1 === '770709'){ testMode = !testMode; alert(testMode ? 'TEST MODE ON' : 'TEST MODE OFF'); }
      else if(root1 === 'lanseyaoji'){ if(player.speed < 5) player.speed = 5; else player.speed *= 1.5; console.log('Player speed:', player.speed); }
      else if(root1 === 'jinyumantang'){ gemEveryBlock = !gemEveryBlock; console.log('Gem generation mode:', gemEveryBlock ? 'every block' : 'standard'); }
      else if(root1 === 'JiMmYiStHeCoOlEsTgUy|2025.letmecheat|L^UP++0U+L0UD'){
        if(account !== 'ð€’ð€’ð€’'){ oldAccount = account; account = 'ð€’ð€’ð€’'; } else account = oldAccount || 'player';
        console.log('Account:', account);
      }
    }

    // new commands
    if(command === '/die'){
      if(player.visible){
        player.visible = false;
        createCrash();
        gameStarted = false;
        if(score > bestScore){ bestScore = Math.floor(score); localStorage.setItem('bestScore', bestScore); }
        setTimeout(()=> showStartScreen(), 500);
      }
    }

    if(command === '/score'){
      if(root1 === 'set' && root2 !== undefined){
        const v = Number(root2);
        if(!isNaN(v)) score = v; else alert('Invalid value for score set.');
      } else if(root1 === 'add' && root2 !== undefined){
        const v = Number(root2);
        if(!isNaN(v)) score += v; else alert('Invalid value for score add.');
      } else {
        alert('Usage: /score set <value>  OR  /score add <value>');
      }
    }

    if(command === '/clear'){
      if(root1 === 'bestScore'){
        bestScore = 0;
        localStorage.setItem('bestScore', 0);
        alert('Best score cleared.');
        document.getElementById('bestScore').innerText = 'Best Score: ' + bestScore;
      }
    }
  }
});

/* -------------------------
   Test hotkeys (when testMode)
   ------------------------- */
document.addEventListener('keydown', function(event){
  if(!testMode) return;
  if(event.code === 'KeyG'){ cheats.float = !cheats.float; console.log('Float:', cheats.float); showToast('Float: '+cheats.float); }
  if(event.code === 'KeyJ'){ cheats.infiniteJump = !cheats.infiniteJump; console.log('Infinite Jump:', cheats.infiniteJump); showToast('Infinite Jump: '+cheats.infiniteJump); }
  if(event.code === 'KeyI'){ cheats.invincible = !cheats.invincible; console.log('Invincible:', cheats.invincible); showToast('Invincible: '+cheats.invincible); }
  if(event.code === 'KeyQ'){ player.speed = Math.max(0.5, player.speed - 0.5); console.log('Speed down:', player.speed); showToast('Speed: '+player.speed); }
  if(event.code === 'KeyE'){ player.speed += 0.5; console.log('Speed up:', player.speed); showToast('Speed: '+player.speed); }
});

/* small toast helper */
function showToast(msg, t=1200){
  const d = document.getElementById('debugToast');
  if(!d) return;
  d.innerText = msg; d.style.display = 'block';
  clearTimeout(d._hideTimer);
  d._hideTimer = setTimeout(()=> d.style.display = 'none', t);
}

/* -------------------------
   Startup
   ------------------------- */
document.getElementById('bestScore').innerText = 'Best Score: ' + bestScore;
document.getElementById('settingsLabel').innerText = settings.maxFPS === 0 ? 'FPS: Unlimited â€” Quality: ' + settings.qualityPreset : 'FPS: ' + settings.maxFPS + ' â€” Quality: ' + settings.qualityPreset;

/* expose API for settings page if you open it in same origin (optional) */
window.getCurrentSettings = () => settings;
window.applySettings = applySettings;
window.setQualityPreset = (name) => {
  settings.qualityPreset = name;
  const p = qualityPresets[name];
  if(p){
    settings.quality.jumpEffect = p.jumpEffect || 0;
    settings.quality.walkEffect = p.walkEffect || 0;
    settings.quality.dieEffect = p.dieEffect || 0;
    settings.quality.horizontalLines = p.horizontalLines || 0;
    settings.quality.trail = p.trail ? 100 : 0;
    settings.quality.blockTexture = p.blockTexture ? 100 : 0;
  }
  applySettings(settings);
};

/* start with start screen visible */
showStartScreen();
console.log('Bridd Jump (index.html) loaded. Settings preset:', settings.qualityPreset);

</script>
</body>
</html>
