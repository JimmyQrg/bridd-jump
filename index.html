<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultra-Fancy Platformer</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  canvas { display:block; }
  #ui { position:absolute; top:0; left:0; width:100%; text-align:center; pointer-events:none; }
  #startScreen {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.95); display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow: 0 0 10px #0ff;
  }
  button { font-size:28px; padding:15px 30px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:10px; transition: 0.3s; }
  button:hover { color:black; background:#0ff; }
  h1 { font-size:60px; margin-bottom:20px; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>NEON RUNNER</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">Start Game</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gravity = 0.7;
let keys = {};
let score = 0;
let bestScore = 0;
let lastTime = 0;
let gameStarted = false;
let shakeIntensity = 0;

// Player
let player = {
    x: 100, y: 300, width: 50, height: 50,
    color: "#0ff", vy: 0, speed: 5, trail: [],
    glow: true, hitboxScale: 0.6
};

// Effects
let platforms = [];
let spikes = [];
let particles = [];
let backgroundParticles = [];
let whiteLines = [];

// Key handling
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);

// Background particles
function generateBackgroundParticles(count=200){
    for(let i=0;i<count;i++){
        backgroundParticles.push({
            x:Math.random()*canvas.width,
            y:Math.random()*canvas.height,
            vx:0, vy:0,
            size:Math.random()*2+1,
            color:"#0ff",
            alpha:Math.random()*0.5+0.1
        });
    }
}
generateBackgroundParticles(200);

// White horizontal motion lines
function generateWhiteLines(count=50){
    for(let i=0;i<count;i++){
        whiteLines.push({
            y: Math.random()*canvas.height,
            speed: Math.random()*5+2,
            length: Math.random()*200+50,
            alpha: Math.random()*0.3+0.1
        });
    }
}
generateWhiteLines(50);

// Particle creation
function createExplosion(x, y, color, amount=50) {
    for(let i=0;i<amount;i++){
        particles.push({
            x:x, y:y,
            vx:(Math.random()-0.5)*15,
            vy:(Math.random()-0.5)*15-2,
            size:Math.random()*6+2,
            color:color,
            alpha:1
        });
    }
}
function createTrail(x,y,color){
    player.trail.push({x,y,color,alpha:1,size:Math.random()*6+4});
}

// Platforms
function generatePlatform(lastX, lastY){
    let width = Math.random()*200+100;
    let height = 20;
    let x = lastX + Math.random()*200+150;
    let y = lastY + (Math.random()-0.5)*150;
    y = Math.max(50,Math.min(canvas.height-100,y));
    
    // Add gradient/texture for fancy platform
    let color = `hsl(${Math.random()*360},100%,50%)`;
    platforms.push({x,y,width,height,color});
    
    // Bigger spikes
    if(Math.random()>0.5 && width>120){
        let spikeX = x+Math.random()*(width-40);
        spikes.push({x:spikeX,y:y-30,width:40,height:30});
    }
    return {x,y};
}

// Reset game
function resetGame(){
    score=0;
    player.x=100; player.y=300; player.vy=0; player.speed=5; player.trail=[];
    platforms=[]; spikes=[]; particles=[];
    lastPlatform = generatePlatform(0, canvas.height/2);
}

// Death
function die(){
    createExplosion(player.x+player.width/2, player.y+player.height/2,"#0ff",150);
    shakeIntensity=15;
    if(score>bestScore) bestScore=Math.floor(score);
    document.getElementById("bestScore").innerText = "Best Score: "+bestScore;
    showStartScreen();
    gameStarted=false;
}

// UI
function showStartScreen(){ document.getElementById("startScreen").style.display="flex"; }
function hideStartScreen(){ document.getElementById("startScreen").style.display="none"; }

// Spike collision with smaller hitbox
function checkSpikeCollision(spike){
    const hbWidth = player.width*player.hitboxScale;
    const hbHeight = player.height*player.hitboxScale;
    const hbX = player.x + (player.width - hbWidth)/2;
    const hbY = player.y + (player.height - hbHeight)/2;
    return hbX+hbWidth>spike.x && hbX<spike.x+spike.width &&
           hbY+hbHeight>spike.y && hbY<spike.y+spike.height;
}

// Main loop
function update(time){
    if(!gameStarted) return requestAnimationFrame(update);
    let delta = (time-lastTime)/1000;
    lastTime=time;

    let camShakeX = (Math.random()-0.5)*shakeIntensity;
    let camShakeY = (Math.random()-0.5)*shakeIntensity;
    if(shakeIntensity>0) shakeIntensity*=0.9;

    let camX = player.x-150+camShakeX;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // White horizontal lines
    for(let line of whiteLines){
        ctx.strokeStyle = `rgba(255,255,255,${line.alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-line.length+Math.random()*10, line.y);
        ctx.lineTo(line.length+Math.random()*10, line.y);
        ctx.stroke();
        line.y += line.speed;
        if(line.y>canvas.height) line.y=0;
    }

    // Background particles
    for(let bp of backgroundParticles){
        ctx.fillStyle = `rgba(0,255,255,${bp.alpha})`;
        ctx.fillRect(bp.x, bp.y, bp.size, bp.size);
    }

    // Score
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle="#fff"; ctx.font="40px sans-serif";
    ctx.fillText(Math.floor(score),20,50);
    ctx.shadowBlur=0;

    // Player physics (jump constant)
    if((keys["KeyW"]||keys["ArrowUp"]||keys["Space"]) && player.vy===0){
        player.vy=-15;
        for(let i=0;i<10;i++){ createTrail(player.x+player.width/2,player.y+player.height,"#0ff"); }
    }
    player.vy+=gravity;
    player.y+=player.vy;

    // Horizontal movement & slow speed increase
    player.x += player.speed;
    player.speed += 0.00005; // slower acceleration

    // Player trail
    for(let i=player.trail.length-1;i>=0;i--){
        let t = player.trail[i];
        ctx.fillStyle=`rgba(0,255,255,${t.alpha})`;
        ctx.fillRect(t.x-camX,t.y,t.size,t.size);
        t.alpha-=0.05; t.y-=0.5;
        if(t.alpha<=0) player.trail.splice(i,1);
    }

    // Platform collision
    let onGround=false;
    for(let plat of platforms){
        if(player.x+player.width>plat.x && player.x<plat.x+plat.width &&
           player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
            player.y=plat.y-player.height; player.vy=0; onGround=true;
        }
    }
    if(!onGround && player.y>canvas.height) die();

    // Draw platforms with gradient texture
    for(let plat of platforms){
        let grad = ctx.createLinearGradient(plat.x-camX, plat.y, plat.x-camX+plat.width, plat.y);
        grad.addColorStop(0, "#0ff");
        grad.addColorStop(0.5, plat.color);
        grad.addColorStop(1, "#0ff");
        ctx.fillStyle = grad;
        ctx.fillRect(plat.x-camX, plat.y, plat.width, plat.height);
    }

    // Spikes
    for(let spike of spikes){
        ctx.fillStyle="red";
        ctx.beginPath();
        ctx.moveTo(spike.x-camX, spike.y+spike.height);
        ctx.lineTo(spike.x-camX+spike.width/2, spike.y);
        ctx.lineTo(spike.x-camX+spike.width, spike.y+spike.height);
        ctx.closePath();
        ctx.fill();
        if(Math.random()<0.2) particles.push({x:spike.x+spike.width/2,y:spike.y, vx:(Math.random()-0.5)*2, vy:Math.random()*-2, size:2, color:"red", alpha:1});
        if(checkSpikeCollision(spike)) die();
    }

    // Glowing player
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle=player.color;
    ctx.fillRect(player.x-camX, player.y, player.width, player.height);
    ctx.shadowBlur=0;

    // Particles update
    for(let i=particles.length-1;i>=0;i--){
        let p=particles[i];
        p.x+=p.vx; p.y+=p.vy; p.vy+=0.3; p.alpha-=0.03;
        ctx.fillStyle=`rgba(0,255,255,${p.alpha})`;
        ctx.fillRect(p.x-camX,p.y,p.size,p.size);
        if(p.alpha<=0) particles.splice(i,1);
    }

    // Dynamic platforms
    let last = platforms[platforms.length-1];
    if(last.x<player.x+canvas.width) generatePlatform(last.x,last.y);

    score += delta*100;

    requestAnimationFrame(update);
}

// Start button
document.getElementById("startBtn").addEventListener("click",()=>{
    hideStartScreen();
    resetGame();
    gameStarted=true;
    lastTime=performance.now();
    requestAnimationFrame(update);
});

showStartScreen();
</script>
</body>
</html>
