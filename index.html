<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SmileMo Merged</title>
<style>
  body {
    margin:0;
    overflow:hidden;
    background:#000;
    font-family:"Josefin Sans", sans-serif;
    color:white;
  }
  canvas {
    display:block;
    background:#111;
  }
  #commandBox {
    position:absolute;
    bottom:0;
    left:0;
    width:100%;
    box-sizing:border-box;
    background:rgba(0,0,0,0.8);
    color:#0f0;
    font-family:monospace;
    padding:5px;
    border:none;
    outline:none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<input id="commandBox" placeholder="Type command and press Enter">
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let keys = {};
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

// --- Player ---
let player = {
  x:100, y:100,
  w:40, h:40,
  dx:0, dy:0,
  onGround:false,
  color:"yellow",
  dead:false
};

// --- World ---
let gravity = 0.6;
let jumpPower = -12;
let platforms = [];
let spikes = [];
let gems = [];
let particles = [];
let scrollX = 0;
let gameOver = false;
let testMode = false;

// --- Utilities ---
function rectCollide(a, b) {
  return a.x < b.x+b.w && a.x+a.w > b.x &&
         a.y < b.y+b.h && a.y+a.h > b.y;
}

// --- Particles ---
function spawnParticles(x, y, color) {
  for (let i=0;i<10;i++) {
    particles.push({
      x, y,
      dx:(Math.random()-0.5)*6,
      dy:(Math.random()-1)*6,
      life:30,
      color
    });
  }
}
// --- Generate Platforms, Spikes, Gems ---
let lastPlatformX = 0;
let lastPlatformY = canvas.height - 100;

function generateLevel() {
  for (let i=0; i<300; i++) { // 100x longer
    let gap = 200 + Math.random()*100;
    let x = lastPlatformX + gap;
    let y = lastPlatformY + (Math.random()*160 - 80);
    if (y > canvas.height-60) y = canvas.height-60;
    if (y < 200) y = 200;
    let w = 200;
    platforms.push({x, y, w, h:20, color:"green"});
    // Virus spike
    if (Math.random()<0.2) {
      spikes.push({x:x+Math.random()*w, y:y-40, w:30, h:40, color:"red"});
    }
    // Gem
    if (Math.random()<0.1) {
      gems.push({x:x+Math.random()*w, y:y-60, w:20, h:20, color:"cyan"});
    }
    lastPlatformX = x;
    lastPlatformY = y;
  }
}

// --- Update Player ---
function updatePlayer() {
  if (keys["ArrowLeft"]) player.dx = -5;
  else if (keys["ArrowRight"]) player.dx = 5;
  else player.dx = 0;

  if (keys["Space"] && player.onGround) {
    player.dy = jumpPower;
    player.onGround = false;
    spawnParticles(player.x+player.w/2, player.y+player.h, "yellow");
  }

  // Gravity
  player.dy += gravity;
  player.x += player.dx;
  player.y += player.dy;

  // Collisions with platforms
  player.onGround = false;
  for (let p of platforms) {
    if (rectCollide(player, p)) {
      if (player.dy > 0 && player.y+player.h <= p.y+20) {
        player.y = p.y - player.h;
        player.dy = 0;
        player.onGround = true;
      }
    }
  }

  // Collisions with spikes (viruses)
  for (let s of spikes) {
    if (rectCollide(player, s)) {
      crash();
    }
  }

  // Collect gems
  for (let i=gems.length-1; i>=0; i--) {
    if (rectCollide(player, gems[i])) {
      spawnParticles(gems[i].x, gems[i].y, "cyan");
      gems.splice(i,1);
    }
  }

  // Void death
  if (player.y > canvas.height + 200) {
    crash();
  }
}

// --- Crash / Death ---
function crash() {
  if (!player.dead) {
    player.dead = true;
    spawnParticles(player.x, player.y, "red");
    shakeTimer = 20;
  }
}

// --- Screen Shake ---
let shakeTimer = 0;
function applyShake() {
  if (shakeTimer > 0) {
    shakeTimer--;
    ctx.translate((Math.random()-0.5)*10, (Math.random()-0.5)*10);
  }
}
// --- Draw Everything ---
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  applyShake();

  ctx.translate(-scrollX,0);

  // Platforms
  for (let p of platforms) {
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.w, p.h);
  }

  // Spikes (viruses)
  for (let s of spikes) {
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y+s.h);
    ctx.lineTo(s.x+s.w/2, s.y);
    ctx.lineTo(s.x+s.w, s.y+s.h);
    ctx.closePath();
    ctx.fill();
  }

  // Gems
  for (let g of gems) {
    ctx.fillStyle = g.color;
    ctx.beginPath();
    ctx.arc(g.x+g.w/2, g.y+g.h/2, g.w/2, 0, Math.PI*2);
    ctx.fill();
  }

  // Player
  if (!player.dead) {
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x, player.y, player.w, player.h);
  }

  // Particles
  for (let i=particles.length-1; i>=0; i--) {
    let pa = particles[i];
    ctx.fillStyle = pa.color;
    ctx.fillRect(pa.x, pa.y, 4, 4);
    pa.x += pa.dx;
    pa.y += pa.dy;
    pa.dy += 0.3;
    pa.life--;
    if (pa.life<=0) particles.splice(i,1);
  }

  ctx.restore();
}

// --- Command System ---
const commandBox = document.getElementById("commandBox");
commandBox.addEventListener("keydown", e => {
  if (e.key === "Enter") {
    let cmd = commandBox.value.trim();
    runCommand(cmd);
    commandBox.value = "";
  }
});

function runCommand(cmd) {
  let parts = cmd.split(" ");
  if (parts[0]==="teleport" && parts.length===3) {
    player.x = parseInt(parts[1]);
    player.y = parseInt(parts[2]);
  }
  else if (parts[0]==="jump") {
    player.dy = jumpPower;
  }
  else if (parts[0]==="testmode") {
    testMode = !testMode;
    console.log("Test mode:", testMode);
  }
}

// --- Test Mode Controls ---
function handleTestMode() {
  if (testMode) {
    if (keys["KeyW"]) player.y -= 5;
    if (keys["KeyS"]) player.y += 5;
    if (keys["KeyA"]) player.x -= 5;
    if (keys["KeyD"]) player.x += 5;
  }
}

// --- Game Loop ---
function gameLoop() {
  if (!player.dead) {
    updatePlayer();
    handleTestMode();
    scrollX = player.x - 200;
  }
  draw();
  requestAnimationFrame(gameLoop);
}

// --- Start ---
generateLevel();
gameLoop();
</script>
</body>
</html>
