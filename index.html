<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Schedule | Infinite Campus</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
canvas { display:block; }
#ui { position:absolute; top:0; left:0; width:100%; height:100%; text-align:center; pointer-events:none; }
#startScreen {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:400px; padding:40px; background:rgba(0,0,0,0.9);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow:0 0 20px #0ff;
    border:3px solid #0ff; border-radius:20px;
}
button { font-size:32px; padding:15px 40px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:12px; transition:0.3s; }
button:hover { color:black; background:#0ff; }
h1 { font-size:60px; margin-bottom:20px; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; animation: glow 1.5s infinite alternate; }
@keyframes glow { 0% { text-shadow:0 0 10px #0ff,0 0 20px #0ff;} 100% {text-shadow:0 0 40px #0ff,0 0 80px #0ff;} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">START</button>
  </div>
</div>

<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const BLOCK_SIZE=50;
const JUMP_SPEED=-15;
const GRAVITY=0.7;
const strikeChance=0.3;

let score=0, bestScore=localStorage.getItem("bestScore")?parseInt(localStorage.getItem("bestScore")):0;
let platforms=[], spikes=[], gems=[], lines=[], crashPieces=[], particles=[];
let gameStarted=false, animationFrameId, lastTime=0, globalTime=0;
let cameraX=0, cameraY=0;

let player={
    x:100, y:0, width:50, height:50,
    vy:0, speed:8, jumpsLeft:2, onGround:false, visible:true,
    horizMultiplier:1, vertMultiplier:1, hitboxScale:0.6, color:"#0ff"
};

let baseColors=[{r:255,g:0,b:0},{r:255,g:153,b:0},{r:255,g:255,b:0},{r:0,g:255,b:0},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:153,g:0,b:255}];
let platformColor={...baseColors[0]}, nextColor={...baseColors[1]}, colorIndex=0, colorLerp=0;

// Cheats & commands
let testMode=false, gemEveryBlock=false, cheatsUnlocked=false;
let cheats={float:false, invincible:false, infiniteJump:false};
let account="player", oldAccount=null;

// --- INPUT ---
function jump(){if(!player.visible) return;if(cheats.infiniteJump||player.jumpsLeft>0){player.vy=JUMP_SPEED;spawnParticles(player.x+player.width/2,player.y+player.height,player.jumpsLeft===2?"jump":"double");if(!cheats.infiniteJump)player.jumpsLeft--;}}
window.addEventListener("keydown", e=>{if(["KeyW","ArrowUp","Space"].includes(e.code)) jump();});
window.addEventListener("mousedown", jump);
window.addEventListener("touchstart", jump);

// --- UTILS ---
function lerpColor(c1,c2,t){return {r:c1.r+(c2.r-c1.r)*t, g:c1.g+(c2.g-c1.g)*t, b:c1.b+(c2.b-c1.b)*t};}
function spawnParticles(x,y,type){const color=type==="jump"?"#0ff":type==="double"?"#ff0":"#fff";for(let i=0;i<15;i++){particles.push({x,y,vx:(Math.random()-0.5)*5,vy:(Math.random()-1.5)*5,life:Math.random()*30+20,color});}}
function checkSpikeCollision(spike){const hbW=player.width*player.hitboxScale;const hbH=player.height*player.hitboxScale;const hbX=player.x+(player.width-hbW)/2;const hbY=player.y+(player.height-hbH)/2;return hbX+hbW>spike.x&&hbX<spike.x+spike.width&&hbY+hbH>spike.y&&hbY<spike.y+spike.height;}
function createCrash(){for(let i=0;i<20;i++){crashPieces.push({x:player.x+Math.random()*player.width,y:player.y+Math.random()*player.height,vx:(Math.random()-0.5)*15,vy:(Math.random()-1)*15,size:Math.random()*player.width/4+5,color:player.color});}}

// --- GAME ---
function resetGame(){
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    score=0; colorLerp=0; globalTime=0;
    player.x=100; player.y=canvas.height/2-player.height; player.vy=0; player.speed=8;
    player.jumpsLeft=2; player.onGround=false; player.visible=true; player.horizMultiplier=1; player.vertMultiplier=1;
    platforms=[]; spikes=[]; crashPieces=[]; particles=[]; gems=[]; lines=[];
    platformColor={...baseColors[0]}; colorIndex=0; nextColor=baseColors[1];
    platforms.push({x:0, y:player.y+player.height, width:BLOCK_SIZE*10, height:BLOCK_SIZE, color:{...platformColor}, passed:false});
    lastTime=performance.now(); hideStartScreen(); gameStarted=true; animationFrameId=requestAnimationFrame(update);
}

function generateBlockPlatform(lastX,lastY){
    let blockCount=Math.floor(Math.random()*8)+1; if(Math.random()<0.7) blockCount=Math.min(blockCount,Math.floor(Math.random()*3+1));
    let gap=Math.floor(Math.random()*5+3)*BLOCK_SIZE; let x=lastX+gap; let y=lastY+(Math.floor(Math.random()*3)-1)*BLOCK_SIZE; y=Math.max(BLOCK_SIZE,Math.min(canvas.height-3*BLOCK_SIZE,y));
    for(let i=0;i<blockCount;i++){platforms.push({x:x+i*BLOCK_SIZE,y,width:BLOCK_SIZE,height:BLOCK_SIZE,color:{...platformColor}, passed:false}); if(Math.random()<strikeChance) spikes.push({x:x+i*BLOCK_SIZE+BLOCK_SIZE*0.2,y:y-BLOCK_SIZE+BLOCK_SIZE*0.2,width:BLOCK_SIZE*0.6,height:BLOCK_SIZE*0.6, baseY:y-BLOCK_SIZE+BLOCK_SIZE*0.2, hit:true, passed:false});}
    for(let i=0;i<blockCount;i++){if(Math.random()<0.1){let gemX=x+i*BLOCK_SIZE+BLOCK_SIZE/4;let gemY=y-BLOCK_SIZE*1.5;let safe=true;for(let s of spikes){if(Math.abs(gemX-s.x)<BLOCK_SIZE*2)safe=false;}if(safe) gems.push({x:gemX,y:gemY,size:20,collected:false,floatOffset:Math.random()*Math.PI*2});}}
    return {x:x+blockCount*BLOCK_SIZE,y};
}

function tryDie(spike){if(!player.visible) return;if(!cheats.invincible){player.visible=false; createCrash(); gameStarted=false; if(score>bestScore){bestScore=Math.floor(score); localStorage.setItem("bestScore",bestScore);} setTimeout(showStartScreen,1000);}}

function showStartScreen(){ document.getElementById("startScreen").style.display="flex"; document.getElementById("bestScore").innerText="Best Score: "+bestScore;}
function hideStartScreen(){ document.getElementById("startScreen").style.display="none";}
document.getElementById("startBtn").addEventListener("click", resetGame);

// --- COMMAND SYSTEM ---
window.addEventListener("keydown", e=>{
    if(e.ctrlKey && e.shiftKey && e.code==="KeyA"){
        const input=prompt("Enter command:"); if(!input) return;
        const args=input.trim().split(/\s+/); const command=args[0]; const root1=args[1]; const root2=args[2]; const root3=args[3]; const root4=args[4];

        if(command==="/gamerule"){switch(root1){case "infiniteJump": cheats.infiniteJump=root2==="true"; break; case "death": cheats.invincible=root2==="false"; break; case "speed": if(!player.speedMultiplier)player.speedMultiplier=1; if(root2==="reset")player.speedMultiplier=1; if(root2==="add"&&!isNaN(parseFloat(root3))) player.speedMultiplier+=parseFloat(root3); if(root2==="set"&&!isNaN(parseFloat(root3))) player.speedMultiplier=parseFloat(root3); if(root4){switch(root4.toLowerCase()){case "horizontal": player.horizMultiplier=player.speedMultiplier; break; case "vertical": player.vertMultiplier=player.speedMultiplier; break; case "both": player.horizMultiplier=player.vertMultiplier=player.speedMultiplier; break;}} else{player.horizMultiplier=player.vertMultiplier=player.speedMultiplier;} break;}}
        if(command==="/variable"){if(!root1){let acc=localStorage.getItem("account")||"player"; let isCreator=["bw55133@pausd.us","ikunbeautiful@gmail.com","benranwu@gmail.com"].includes(acc); alert("test mode: "+cheatsUnlocked+"\n"+"infinite jump: "+cheats.infiniteJump+"\n"+"float: "+cheats.float+"\n"+"death: "+(!cheats.invincible)+"\n"+"score: "+score+"\n"+"best score: "+bestScore+"\n"+"account: "+(isCreator?"creator":"player")+"\n"+"player speed: "+player.speed+"\n"+"jump height: "+(-JUMP_SPEED));}}
        if(command==="/code"){if(root1==="770709"){testMode=!testMode; alert(testMode?"TEST MODE ON":"TEST MODE OFF");} else if(root1==="lanseyaoji"){if(player.speed<5)player.speed=5; else player.speed*=1.5; console.log("Player speed:",player.speed);} else if(root1==="jinyumantang"){gemEveryBlock=!gemEveryBlock; console.log("Gem generation:",gemEveryBlock?"every block":"standard");} else if(root1==="JiMmYiStHeCoOlEsTgUy|2025.letmecheat|L^UP++0U+L0UD"){if(account!=="𐀒𐀒𐀒"){oldAccount=account; account="𐀒𐀒𐀒";} else{account=oldAccount||"player";} console.log("Account:",account);}}
    }
});

// --- TEST-MODE HOTKEYS ---
document.addEventListener("keydown", function(event){
    if(!testMode) return;
    if(event.code==="KeyG"){ cheats.float=!cheats.float; console.log("Float:",cheats.float);}
    if(event.code==="KeyJ"){ cheats.infiniteJump=!cheats.infiniteJump; console.log("Infinite Jump:",cheats.infiniteJump);}
    if(event.code==="KeyI"){ cheats.invincible=!cheats.invincible; console.log("Death enabled:",!cheats.invincible);}
    if(event.code==="KeyQ"){ player.speed=Math.max(0.5,player.speed-0.5); console.log("Speed decreased:",player.speed);}
    if(event.code==="KeyE"){ player.speed+=0.5; console.log("Speed increased:",player.speed);}
});

// --- UPDATE LOOP ---
function update(time){
    let delta=(time-lastTime)/1000; lastTime=time; globalTime+=delta;
    if(gameStarted && player.visible){
        player.speed+=0.002; player.y+=player.vy; player.vy+=GRAVITY*player.vertMultiplier; player.x+=player.speed*player.horizMultiplier; player.onGround=false;
        colorLerp+=delta/25; if(colorLerp>=1){ colorIndex=(colorIndex+1)%baseColors.length; nextColor=baseColors[(colorIndex+1)%baseColors.length]; colorLerp=0;}
        platformColor=lerpColor(baseColors[colorIndex],nextColor,colorLerp);

        for(let plat of platforms){
            if(player.x+player.width>plat.x && player.x<plat.x+plat.width && player.y+player.height>plat.y && player.y+player.height<plat.y+player.vy+10){ player.y=plat.y-player.height; player.vy=0; player.onGround=true; player.jumpsLeft=2; plat.passed=true;}
            if(!plat.passed && player.x>plat.x+plat.width){ score+=1; plat.passed=true;}
        }

        for(let spike of spikes){ if(checkSpikeCollision(spike)) tryDie(spike);}
        for(let g of gems){ if(!g.collected && player.x+player.width>g.x && player.x<g.x+g.size && player.y+player.height>g.y && player.y<g.y+g.size){ score+=50; g.collected=true; spawnParticles(g.x+g.size/2,g.y+g.size/2,"double");}}
        let lastPlatform=platforms[platforms.length-1]; if(lastPlatform.x<player.x+canvas.width) generateBlockPlatform(lastPlatform.x,lastPlatform.y);
    }

    cameraX=cameraX*0.9+player.x-150*0.1; cameraY=cameraY*0.9+player.y-canvas.height/2+player.height*1.5*0.1;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Platforms
    for(let plat of platforms){ ctx.fillStyle=`rgb(${Math.floor(plat.color.r)},${Math.floor(plat.color.g)},${Math.floor(plat.color.b)})`; ctx.fillRect(plat.x-cameraX,plat.y-cameraY,plat.width,plat.height);}

    // Spikes
    for(let s of spikes){ let pulse=Math.sin(globalTime*5+s.x)*5; ctx.fillStyle="red"; ctx.beginPath(); ctx.moveTo(s.x-cameraX,s.baseY+s.height-cameraY+pulse); ctx.lineTo(s.x-cameraX+s.width/2,s.baseY-cameraY+pulse); ctx.lineTo(s.x-cameraX+s.width,s.baseY+s.height-cameraY+pulse); ctx.closePath(); ctx.fill();}

    // Gems
    for(let g of gems){ if(g.collected) continue; let floatY=Math.sin(globalTime*3+g.floatOffset)*5; ctx.save(); ctx.translate(g.x+g.size/2-cameraX, g.y+g.size/2-cameraY+floatY); ctx.rotate(Math.PI/4); ctx.fillStyle="white"; ctx.shadowColor="white"; ctx.shadowBlur=20+10*Math.sin(globalTime*5); ctx.fillRect(-g.size/2,-g.size/2,g.size,g.size); ctx.restore();}

    // Player
    if(player.visible){ ctx.shadowColor="#0ff"; ctx.shadowBlur=20; ctx.fillStyle=player.color; ctx.fillRect(player.x-cameraX,player.y-cameraY,player.width,player.height); ctx.shadowBlur=0; ctx.strokeStyle="#0ff"; ctx.lineWidth=6; ctx.strokeRect(player.x-cameraX,player.y-cameraY,player.width,player.height);}

    // Crash pieces
    for(let p of crashPieces){ p.vy+=GRAVITY; p.x+=p.vx; p.y+=p.vy; ctx.fillStyle=p.color; ctx.fillRect(p.x-cameraX,p.y-cameraY,p.size,p.size);}

    // Particles
    for(let p of particles){ p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life>0){ ctx.fillStyle=p.color; ctx.fillRect(p.x-cameraX,p.y-cameraY,5,5);} }
    particles=particles.filter(p=>p.life>0);

    ctx.fillStyle="#fff"; ctx.font="40px sans-serif"; ctx.fillText(score,20,50);
    animationFrameId=requestAnimationFrame(update);
}
</script>
</body>
</html>
