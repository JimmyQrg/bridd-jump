        grad.addColorStop(0, rgb(platformColor));
        grad.addColorStop(1, "black");
        ctx.fillStyle = grad;
        ctx.fillRect(plat.x - cameraX, plat.y - cameraY, plat.width, plat.height);
    }

    for (let spike of spikes) {
        let pulse = Math.sin(globalTime * 5 + spike.x) * 5;
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.moveTo(spike.x - cameraX, spike.baseY + spike.height - cameraY + pulse);
        ctx.lineTo(spike.x - cameraX + spike.width / 2, spike.baseY - cameraY + pulse);
        ctx.lineTo(spike.x - cameraX + spike.width, spike.baseY + spike.height - cameraY + pulse);
        ctx.closePath();
        ctx.fill();
    }

    for (let gem of gems) {
        if (gem.collected) continue;
        ctx.save();
        ctx.translate(gem.x + gem.size / 2 - cameraX, gem.y + gem.size / 2 - cameraY);
        ctx.rotate(Math.PI / 4);
        ctx.shadowBlur = 20 * Math.sin(gem.glow);
        ctx.shadowColor = "#fff";
        ctx.fillStyle = "#fff";
        ctx.fillRect(-gem.size / 2, -gem.size / 2, gem.size, gem.size);
        ctx.shadowBlur = 0;
        ctx.restore();
    }

    for (let i = playerTrail.length - 1; i >= 0; i--) {
        let p = playerTrail[i];
        p.life--;
        ctx.fillStyle = `rgba(0,255,255,${p.life / 20})`;
        ctx.fillRect(p.x - cameraX, p.y - cameraY, player.width / 2, player.height / 2);
        if (p.life <= 0) playerTrail.splice(i, 1);
    }

    if (player.visible) drawPlayer();
    for (let t of torches) drawTorch(t);

    for (let i = lines.length - 1; i >= 0; i--) {
        let line = lines[i];
        line.x -= line.speed * 5;
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = Math.random() * 3 + 1;
        ctx.beginPath();
        ctx.moveTo(line.x, line.y);
        ctx.lineTo(line.x + line.width, line.y);
        ctx.stroke();
        if (line.x + line.width < 0) lines.splice(i, 1);
    }

    for (let i = crashPieces.length - 1; i >= 0; i--) {
        let p = crashPieces[i];
        p.vy += GRAVITY * 0.5;
        p.x += p.vx;
        p.y += p.vy;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - cameraX, p.y - cameraY, p.size, p.size);
        if (p.y > canvas.height) crashPieces.splice(i, 1);
    }

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 50;
        ctx.fillRect(p.x - cameraX, p.y - cameraY, 5, 5);
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i, 1);
    }

    if (!gameStarted && crashPieces.length === 0) showStartScreen();
    requestAnimationFrame(update);
}

document.getElementById("startBtn").addEventListener("click", () => { resetGame(); });
showStartScreen();
</script>
</body>
</html>
