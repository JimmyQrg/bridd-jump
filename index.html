<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Bridd Jump</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:black; }
  #menu {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    text-align:center; color:white; font-family:sans-serif; font-size:24px;
  }
  #menu button {
    margin-top:20px; padding:10px 20px; font-size:20px;
    background:white; color:black; border:none; cursor:pointer;
    border-radius:10px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="menu">
  <h1>Bridd Jump</h1>
  <p id="bestScore">Best Score: 0</p>
  <button id="startBtn">START</button>
</div>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

let gameOver=false, running=false, score=0, bestScore=0;
let player, platforms=[], strikes=[], gems=[];
let cameraX=0, cameraY=0;
let baseSpeed=6, speed=baseSpeed, speedIncrease=0.002;
let rainbowColors=["#ff0000","#ff7f00","#ffff00","#00ff00","#0000ff","#4b0082","#8f00ff"];
let colorIndex=0, colorTimer=0;

const gravity=0.6;
const jumpStrength=12;

class Player{
  constructor(){
    this.x=100;this.y=canvas.height/2;this.vx=0;this.vy=0;
    this.size=30;this.onGround=false;this.jumps=0;
  }
  update(){
    this.vx=speed;
    this.vy+=gravity;
    this.y+=this.vy;
    this.x+=this.vx;
    this.onGround=false;
    for(let p of platforms){
      if(this.x+this.size/2>p.x && this.x-this.size/2<p.x+p.w && this.y+this.size/2>p.y && this.y+this.size/2<this.y+this.vy+this.size/2 && this.vy>0){
        this.y=p.y-this.size/2;
        this.vy=0;this.onGround=true;this.jumps=0;
      }
    }
    for(let s of strikes){
      if(this.x+this.size/3>s.x && this.x-this.size/3<s.x+s.w && this.y+this.size/3>s.y && this.y-this.size/3<s.y+s.h){
        triggerDeath(this.y);
      }
    }
    for(let g of gems){
      if(this.x+this.size/2>g.x && this.x-this.size/2<g.x+g.w && this.y+this.size/2>g.y && this.y-this.size/2<g.y+g.h){
        score+=50;
        g.collected=true;
        particles.push(new Particle(g.x,g.y,30,"white",true));
      }
    }
  }
  draw(){
    ctx.fillStyle="cyan";
    ctx.fillRect(this.x-cameraX-this.size/2,this.y-cameraY-this.size/2,this.size,this.size);
    ctx.strokeStyle="white";
    ctx.lineWidth=4;
    ctx.strokeRect(this.x-cameraX-this.size/2,this.y-cameraY-this.size/2,this.size,this.size);
  }
  jump(){
    if(this.onGround||this.jumps<1){
      this.vy=-jumpStrength;
      this.jumps++;
    }
  }
}

class Platform{
  constructor(x,y,w){this.x=x;this.y=y;this.w=w;this.h=20;}
  draw(color){ctx.fillStyle=color;ctx.fillRect(this.x-cameraX,this.y-cameraY,this.w,this.h);}
}
class Strike{
  constructor(x,y){this.x=x;this.y=y;this.w=40;this.h=40;}
  draw(){ctx.fillStyle="red";ctx.fillRect(this.x-cameraX,this.y-cameraY,this.w,this.h);}
}
class Gem{
  constructor(x,y){this.x=x;this.y=y;this.w=20;this.h=20;this.collected=false;}
  draw(){if(!this.collected){ctx.save();ctx.translate(this.x-cameraX+this.w/2,this.y-cameraY+this.h/2);ctx.rotate(Math.PI/4);ctx.fillStyle="white";ctx.shadowColor="white";ctx.shadowBlur=20;ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);ctx.restore();}}
}

class Particle{
  constructor(x,y,r,color,glow=false){this.x=x;this.y=y;this.r=r;this.color=color;this.life=60;this.vx=(Math.random()-0.5)*6;this.vy=(Math.random()-0.5)*6;this.glow=glow;}
  update(){this.x+=this.vx;this.y+=this.vy;this.life--;}
  draw(){ctx.fillStyle=this.color;ctx.globalAlpha=this.life/60;if(this.glow){ctx.shadowColor=this.color;ctx.shadowBlur=20;}ctx.beginPath();ctx.arc(this.x-cameraX,this.y-cameraY,this.r,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;ctx.shadowBlur=0;}
}

let particles=[];

function triggerDeath(y){
  gameOver=true;running=false;
  let rowY=Math.floor(y/40)*40;
  ctx.strokeStyle="white";ctx.lineWidth=4;
  ctx.strokeRect(0,rowY-cameraY,canvas.width,40);
  for(let i=0;i<40;i++){
    particles.push(new Particle(player.x,player.y,5+Math.random()*10,"cyan"));
  }
  setTimeout(()=>{
    document.getElementById("menu").style.display="block";
    if(score>bestScore){bestScore=score;document.getElementById("bestScore").innerText="Best Score: "+bestScore;}
  },1000);
}

function resetGame(){
  score=0;speed=baseSpeed;
  player=new Player();
  platforms=[];strikes=[];gems=[];particles=[];
  for(let i=0;i<10;i++){
    platforms.push(new Platform(i*40,canvas.height-100,40));
  }
}

function generate(){
  let last=platforms[platforms.length-1];
  let gap=Math.random()<0.7?40*(1+Math.floor(Math.random()*2)):40*(2+Math.floor(Math.random()*2));
  let w=40*(1+Math.floor(Math.random()*8));
  let y=canvas.height-100-40*(Math.floor(Math.random()*3));
  platforms.push(new Platform(last.x+gap,y,w));
  if(Math.random()<0.2){strikes.push(new Strike(last.x+gap+Math.random()*(w-40),y-40));}
  if(Math.random()<0.1){gems.push(new Gem(last.x+gap+Math.random()*(w-20),y-60));}
}

function loop(){
  if(!running) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  player.update();
  colorTimer++;
  if(colorTimer>200){colorIndex=(colorIndex+1)%rainbowColors.length;colorTimer=0;}
  let color=rainbowColors[colorIndex];
  for(let p of platforms){p.draw(color);}
  for(let s of strikes){s.draw();}
  for(let g of gems){g.draw();}
  for(let part of particles){part.update();part.draw();}
  particles=particles.filter(p=>p.life>0);
  player.draw();
  ctx.fillStyle="white";ctx.fillText("Score: "+score,20,40);
  cameraX=player.x-canvas.width/2;cameraY=player.y-canvas.height/2+100;
  speed+=speedIncrease;
  if(platforms[platforms.length-1].x<player.x+canvas.width){generate();}
  requestAnimationFrame(loop);
}

window.addEventListener("keydown",e=>{if(["w","ArrowUp"," "].includes(e.key)){player.jump();}});
window.addEventListener("mousedown",()=>{player.jump();});

document.getElementById("startBtn").onclick=()=>{
  document.getElementById("menu").style.display="none";
  gameOver=false;resetGame();
  if(!running){running=true;loop();}
};
</script>
</body>
</html>
