<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Runner Grid</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  canvas { display:block; }
  #ui { position:absolute; top:0; left:0; width:100%; text-align:center; pointer-events:none; }
  #startScreen {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.95); display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow:0 0 20px #0ff;
  }
  button { font-size:32px; padding:15px 40px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:12px; transition:0.3s; }
  button:hover { color:black; background:#0ff; }
  h1 { font-size:70px; margin-bottom:20px; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; animation: glow 1.5s infinite alternate; }
  @keyframes glow { 0% { text-shadow:0 0 10px #0ff,0 0 20px #0ff;} 100% {text-shadow:0 0 40px #0ff,0 0 80px #0ff;} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>NEON RUNNER</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">START</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const BLOCK_SIZE = 50;
let gravity = 0.7;
let keys = {};
let score = 0;
let bestScore = 0;
let lastTime = 0;
let gameStarted = false;
let shakeIntensity = 0;

// Player
let player = {
    x: 100, y: 0, width: 50, height: 50,
    color: "#0ff", vy: 0, speed: 5, trail: [],
    glow: true, hitboxScale: 0.6
};

// Effects
let platforms = [];
let spikes = [];
let particles = [];
let backgroundParticles = [];
let whiteLines = [];

// Key and click handling
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);
window.addEventListener("mousedown", ()=> jump());
window.addEventListener("touchstart", ()=> jump());

// Jump function
function jump(){
    if(player.vy === 0){
        player.vy = -15;
        for(let i=0;i<10;i++){ createTrail(player.x+player.width/2,player.y+player.height,"#0ff"); }
    }
}

// Background particles
for(let i=0;i<200;i++){
    backgroundParticles.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height,
        size:Math.random()*2+1,
        alpha:Math.random()*0.5+0.1
    });
}

// White horizontal lines moving left
for(let i=0;i<50;i++){
    whiteLines.push({
        x: canvas.width + Math.random()*500,
        y: Math.random()*canvas.height,
        speed: Math.random()*8+2,
        length: Math.random()*200+50,
        alpha: Math.random()*0.3+0.1
    });
}

// Particle creation
function createExplosion(x, y, color, amount=50){
    for(let i=0;i<amount;i++){
        particles.push({
            x:x, y:y,
            vx:(Math.random()-0.5)*15,
            vy:(Math.random()-0.5)*15-2,
            size:Math.random()*6+2,
            color:color,
            alpha:1
        });
    }
}
function createTrail(x,y,color){
    player.trail.push({x,y,color,alpha:1,size:Math.random()*6+4});
}

// Generate grid-based platform
function generateBlockPlatform(lastX, lastY){
    let blockCount = Math.floor(Math.random()*5+2); // 2â€“6 blocks
    let x = lastX + Math.floor(Math.random()*3+2) * BLOCK_SIZE;
    let y = lastY + (Math.floor(Math.random()*3)-1)*BLOCK_SIZE;
    y = Math.max(BLOCK_SIZE, Math.min(canvas.height - 3*BLOCK_SIZE, y));

    for(let i=0;i<blockCount;i++){
        platforms.push({
            x: x + i*BLOCK_SIZE,
            y: y,
            width: BLOCK_SIZE,
            height: BLOCK_SIZE,
            color: `hsl(${Math.random()*360},100%,50%)`
        });

        // Lowered chance for spike
        if(Math.random() < 0.1){
            spikes.push({
                x: x + i*BLOCK_SIZE,
                y: y - BLOCK_SIZE,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE
            });
        }
    }
    return {x: x + blockCount*BLOCK_SIZE, y};
}

// Reset game
function resetGame(){
    score = 0;
    player.x = 100; 
    player.y = canvas.height/2 - player.height; 
    player.vy = 0; 
    player.speed = 5; 
    player.trail = [];
    platforms = [];
    spikes = [];
    particles = [];
    
    // Initial ground under player
    platforms.push({
        x: 0,
        y: player.y + player.height,
        width: canvas.width,
        height: BLOCK_SIZE,
        color: "#0ff"
    });

    lastPlatform = generateBlockPlatform(canvas.width, player.y);
}

// Death
function die(){
    createExplosion(player.x+player.width/2, player.y+player.height/2,"#0ff",150);
    shakeIntensity=15;
    if(score>bestScore) bestScore=Math.floor(score);
    document.getElementById("bestScore").innerText = "Best Score: "+bestScore;
    showStartScreen();
    gameStarted=false;
}

// UI
function showStartScreen(){ document.getElementById("startScreen").style.display="flex"; }
function hideStartScreen(){ document.getElementById("startScreen").style.display="none"; }

// Spike collision with smaller hitbox
function checkSpikeCollision(spike){
    const hbWidth = player.width*player.hitboxScale;
    const hbHeight = player.height*player.hitboxScale;
    const hbX = player.x + (player.width - hbWidth)/2;
    const hbY = player.y + (player.height - hbHeight)/2;
    return hbX+hbWidth>spike.x && hbX<spike.x+spike.width &&
           hbY+hbHeight>spike.y && hbY<spike.y+spike.height;
}

// Main loop
function update(time){
    if(!gameStarted) return requestAnimationFrame(update);
    let delta = (time-lastTime)/1000;
    lastTime = time;

    let camShakeX = (Math.random()-0.5)*shakeIntensity;
    let camShakeY = (Math.random()-0.5)*shakeIntensity;
    if(shakeIntensity>0) shakeIntensity *= 0.9;

    let camX = player.x-150+camShakeX;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // White horizontal lines
    for(let line of whiteLines){
        ctx.strokeStyle = `rgba(255,255,255,${line.alpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(line.x, line.y);
        ctx.lineTo(line.x - line.length, line.y);
        ctx.stroke();
        line.x -= line.speed;
        if(line.x + line.length < 0) line.x = canvas.width + Math.random()*500;
    }

    // Background particles
    for(let bp of backgroundParticles){
        ctx.fillStyle = `rgba(0,255,255,${bp.alpha})`;
        ctx.fillRect(bp.x, bp.y, bp.size, bp.size);
    }

    // Score
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle="#fff"; ctx.font="40px sans-serif";
    ctx.fillText(Math.floor(score),20,50);
    ctx.shadowBlur=0;

    // Player physics
    player.y += player.vy;
    player.vy += gravity;

    // Horizontal movement
    player.x += player.speed;
    player.speed += 0.00005;

    // Player trail
    for(let i=player.trail.length-1;i>=0;i--){
        let t = player.trail[i];
        ctx.fillStyle=`rgba(0,255,255,${t.alpha})`;
        ctx.fillRect(t.x-camX,t.y,t.size,t.size);
        t.alpha-=0.05; t.y-=0.5;
        if(t.alpha<=0) player.trail.splice(i,1);
    }

    // Platform collision
    let onGround=false;
    for(let plat of platforms){
        if(player.x+player.width>plat.x && player.x<plat.x+plat.width &&
           player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
            player.y = plat.y - player.height;
            player.vy = 0;
            onGround=true;
        }
    }
    if(!onGround && player.y>canvas.height) die();

    // Draw platforms
    for(let plat of platforms){
        let grad = ctx.createLinearGradient(plat.x-camX, plat.y, plat.x-camX+plat.width, plat.y);
        grad.addColorStop(0, "#0ff");
        grad.addColorStop(0.5, plat.color);
        grad.addColorStop(1, "#0ff");
        ctx.fillStyle = grad;
        ctx.fillRect(plat.x-camX, plat.y, plat.width, plat.height);
    }

    // Spikes
    for(let spike of spikes){
        ctx.fillStyle="red";
        ctx.beginPath();
        ctx.moveTo(spike.x-camX, spike.y+spike.height);
        ctx.lineTo(spike.x-camX+spike.width/2, spike.y);
        ctx.lineTo(spike.x-camX+spike.width, spike.y+spike.height);
        ctx.closePath();
        ctx.fill();
        if(checkSpikeCollision(spike)) die();
    }

    // Glowing player
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle=player.color;
    ctx.fillRect(player.x-camX, player.y, player.width, player.height);
    ctx.shadowBlur=0;

    // Particles update
    for(let i=particles.length-1;i>=0;i--){
        let p=particles[i];
        p.x+=p.vx; p.y+=p.vy; p.vy+=0.3; p.alpha-=0.03;
        ctx.fillStyle=`rgba(0,255,255,${p.alpha})`;
        ctx.fillRect(p.x-camX,p.y,p.size,p.size);
        if(p.alpha<=0) particles.splice(i,1);
    }

    // Dynamic platforms
    let last = platforms[platforms.length-1];
    if(last.x < player.x + canvas.width) generateBlockPlatform(last.x,last.y);

    score += delta*100;

    requestAnimationFrame(update);
}

// Start button
document.getElementById("startBtn").addEventListener("click", ()=>{
    hideStartScreen();
    resetGame();
    gameStarted=true;
    lastTime=performance.now();
    requestAnimationFrame(update);
});

showStartScreen();
</script>
</body>
</html>
