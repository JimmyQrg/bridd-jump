<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fancy Platformer - Glowing Player & Big Spikes</title>
<style>
  body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
  canvas { display:block; }
  #ui { position:absolute; top:0; left:0; width:100%; text-align:center; pointer-events:none; }
  #startScreen {
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.9); display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff;
  }
  button { font-size:24px; padding:10px 20px; cursor:pointer; margin-top:20px; color:#0ff; background:black; border:2px solid #0ff; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">Start Game</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gravity = 0.7;
let keys = {};
let score = 0;
let bestScore = 0;
let lastTime = 0;
let gameStarted = false;
let shakeIntensity = 0;

// Player
let player = {
    x: 100,
    y: 300,
    width: 50,
    height: 50,
    color: "#0ff",
    vy: 0,
    speed: 5,
    trail: [],
    glow: true,
    hitboxScale: 0.6 // smaller hitbox for spikes
};

// Visual Effects containers
let platforms = [];
let spikes = [];
let particles = [];
let backgroundParticles = [];

// Key handling
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);

// Particle creation
function createExplosion(x, y, color, amount=50) {
    for(let i=0;i<amount;i++){
        particles.push({
            x:x, y:y,
            vx:(Math.random()-0.5)*15,
            vy:(Math.random()-0.5)*15-2,
            size:Math.random()*6+2,
            color:color,
            alpha:1
        });
    }
}
function createTrail(x,y,color){
    player.trail.push({x,y,color,alpha:1,size:Math.random()*6+4});
}

// Background particles
function generateBackgroundParticles(count=200){
    for(let i=0;i<count;i++){
        backgroundParticles.push({
            x:Math.random()*canvas.width,
            y:Math.random()*canvas.height,
            vx:0,
            vy:0,
            size:Math.random()*2+1,
            color:"#0ff",
            alpha:Math.random()*0.5+0.1
        });
    }
}
generateBackgroundParticles(200);

// Generate platforms dynamically
function generatePlatform(lastX, lastY){
    let width = Math.random()*200+100;
    let height = 20;
    let x = lastX + Math.random()*200+150;
    let y = lastY + (Math.random()-0.5)*150;
    y = Math.max(50,Math.min(canvas.height-100,y));
    platforms.push({x,y,width,height,color:`hsl(${Math.random()*360},100%,50%)`});
    
    if(Math.random()>0.5 && width>120){
        let spikeX = x+Math.random()*(width-40); // leave margin
        spikes.push({x:spikeX,y:y-30,width:40,height:30}); // bigger spikes
    }
    return {x,y};
}

// Reset game
function resetGame(){
    score=0;
    player.x=100; player.y=300; player.vy=0; player.speed=5; player.trail=[];
    platforms=[]; spikes=[]; particles=[];
    lastPlatform = generatePlatform(0,canvas.height/2);
}

// Player death
function die(){
    createExplosion(player.x+player.width/2,player.y+player.height/2,"#0ff",100);
    shakeIntensity=15;
    if(score>bestScore) bestScore=Math.floor(score);
    document.getElementById("bestScore").innerText = "Best Score: "+bestScore;
    showStartScreen();
    gameStarted=false;
}

// UI
function showStartScreen(){ document.getElementById("startScreen").style.display="flex"; }
function hideStartScreen(){ document.getElementById("startScreen").style.display="none"; }

// Check collision with spikes using smaller hitbox
function checkSpikeCollision(spike){
    const hbWidth = player.width*player.hitboxScale;
    const hbHeight = player.height*player.hitboxScale;
    const hbX = player.x + (player.width - hbWidth)/2;
    const hbY = player.y + (player.height - hbHeight)/2;
    return hbX+hbWidth>spike.x && hbX<spike.x+spike.width &&
           hbY+hbHeight>spike.y && hbY<spike.y+spike.height;
}

// Main update loop
function update(time){
    if(!gameStarted) return requestAnimationFrame(update);
    let delta = (time-lastTime)/1000;
    lastTime=time;

    // Camera shake
    let camShakeX = (Math.random()-0.5)*shakeIntensity;
    let camShakeY = (Math.random()-0.5)*shakeIntensity;
    if(shakeIntensity>0) shakeIntensity*=0.9;

    let camX = player.x-150+camShakeX;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Background particles
    for(let bp of backgroundParticles){
        ctx.fillStyle = `rgba(0,255,255,${bp.alpha})`;
        ctx.fillRect(bp.x, bp.y, bp.size, bp.size);
        bp.x+=bp.vx; bp.y+=bp.vy;
        if(bp.x<0) bp.x=canvas.width; if(bp.x>canvas.width) bp.x=0;
        if(bp.y<0) bp.y=canvas.height; if(bp.y>canvas.height) bp.y=0;
    }

    // Score glow
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle="#fff"; ctx.font="40px sans-serif";
    ctx.fillText(Math.floor(score),20,50);
    ctx.shadowBlur=0;

    // Player physics
    if((keys["KeyW"]||keys["ArrowUp"]||keys["Space"]) && player.vy===0){
        player.vy=-15;
        for(let i=0;i<10;i++){ createTrail(player.x+player.width/2,player.y+player.height,"#0ff"); }
    }
    player.vy+=gravity;
    player.y+=player.vy;
    player.x+=player.speed; player.speed+=0.0005;

    // Player trail
    for(let i=player.trail.length-1;i>=0;i--){
        let t = player.trail[i];
        ctx.fillStyle=`rgba(0,255,255,${t.alpha})`;
        ctx.fillRect(t.x-camX,t.y,t.size,t.size);
        t.alpha-=0.05; t.y-=0.5;
        if(t.alpha<=0) player.trail.splice(i,1);
    }

    // Platform collision
    let onGround=false;
    for(let plat of platforms){
        if(player.x+player.width>plat.x && player.x<plat.x+plat.width &&
            player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
            player.y=plat.y-player.height; player.vy=0; onGround=true;
        }
    }
    if(!onGround && player.y>canvas.height) die();

    // Draw platforms
    for(let plat of platforms){
        ctx.shadowColor=plat.color; ctx.shadowBlur=15;
        ctx.fillStyle=plat.color;
        ctx.fillRect(plat.x-camX,plat.y,plat.width,plat.height);
    }
    ctx.shadowBlur=0;

    // Draw spikes with sparks
    for(let spike of spikes){
        ctx.fillStyle="red";
        ctx.beginPath();
        ctx.moveTo(spike.x-camX,spike.y+spike.height);
        ctx.lineTo(spike.x-camX+spike.width/2,spike.y);
        ctx.lineTo(spike.x-camX+spike.width,spike.y+spike.height);
        ctx.closePath();
        ctx.fill();
        if(Math.random()<0.2) particles.push({x:spike.x+spike.width/2,y:spike.y, vx:(Math.random()-0.5)*2, vy:Math.random()*-2, size:2, color:"red", alpha:1});
        if(checkSpikeCollision(spike)) die();
    }

    // Draw glowing player
    ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
    ctx.fillStyle=player.color;
    ctx.fillRect(player.x-camX,player.y,player.width,player.height);
    ctx.shadowBlur=0;

    // Particle updates
    for(let i=particles.length-1;i>=0;i--){
        let p=particles[i];
        p.x+=p.vx; p.y+=p.vy; p.vy+=0.3; p.alpha-=0.03;
        ctx.fillStyle=`rgba(0,255,255,${p.alpha})`; ctx.fillRect(p.x-camX,p.y,p.size,p.size);
        if(p.alpha<=0) particles.splice(i,1);
    }

    // Generate new platforms dynamically
    let last = platforms[platforms.length-1];
    if(last.x<player.x+canvas.width) generatePlatform(last.x,last.y);

    // Increase score over time
    score+=delta*100;

    requestAnimationFrame(update);
}

// Start button
document.getElementById("startBtn").addEventListener("click",()=>{
    hideStartScreen();
    resetGame();
    gameStarted=true;
    lastTime=performance.now();
    requestAnimationFrame(update);
});

showStartScreen();
</script>
</body>
</html>
