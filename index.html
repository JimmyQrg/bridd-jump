<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bridd Jump</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
canvas { display:block; }
#ui { position:absolute; top:0; left:0; width:100%; text-align:center; pointer-events:none; }
#startScreen {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:400px; padding:40px; background:rgba(0,0,0,0.9);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow:0 0 20px #0ff;
    border:3px solid #0ff; border-radius:20px;
}
button { font-size:32px; padding:15px 40px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:12px; transition:0.3s; }
button:hover { color:black; background:#0ff; }
h1 { font-size:60px; margin-bottom:20px; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; animation: glow 1.5s infinite alternate; }
@keyframes glow { 0% { text-shadow:0 0 10px #0ff,0 0 20px #0ff;} 100% {text-shadow:0 0 40px #0ff,0 0 80px #0ff;} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">START</button>
  </div>
</div>

<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const BLOCK_SIZE=50;
const JUMP_SPEED=-15;
const GRAVITY=0.7;

let keys={}, score=0, bestScore=0, lastTime=0, gameStarted=false, animationId=null;
let crashPieces=[], particles=[];
let rainbowColors=["#ff0000","#ff9900","#ffff00","#00ff00","#00ffff","#0000ff","#9900ff"]; 
let rainbowIndex=0; let blocksPerColor=0;

let player={
    x:100, y:0, width:50, height:50,
    color:"#0ff", vy:0, speed:5,
    hitboxScale:0.6, jumpsLeft:1, onGround:false
};

let platforms=[], spikes=[];

// Input
window.addEventListener("keydown", e=>{ if(["KeyW","ArrowUp","Space"].includes(e.code)) jump(); keys[e.code]=true; });
window.addEventListener("keyup", e=>keys[e.code]=false);
window.addEventListener("mousedown", ()=>jump());
window.addEventListener("touchstart", ()=>jump());

function jump(){
    if(player.jumpsLeft>0){
        player.vy=JUMP_SPEED;
        spawnParticles(player.x+player.width/2, player.y+player.height, player.jumpsLeft===2?"jump":"double");
        player.jumpsLeft--;
    }
}

function resetGame(){
    if(animationId) cancelAnimationFrame(animationId);

    score=0;
    player.x=100; 
    player.y=canvas.height/2-player.height; 
    player.vy=0; 
    player.speed=5;
    player.jumpsLeft=1; 
    player.onGround=false;

    platforms=[]; spikes=[]; crashPieces=[]; particles=[];
    rainbowIndex=0; blocksPerColor=0;

    platforms.push({x:0,y:player.y+player.height,width:canvas.width/2,height:BLOCK_SIZE,color:rainbowColors[rainbowIndex]});
    generateBlockPlatform(canvas.width/2,player.y+player.height);

    lastTime=performance.now();
    hideStartScreen();
    gameStarted=true;
    update(lastTime);
}

function generateBlockPlatform(lastX,lastY){
    let blockCount=Math.floor(Math.random()*5+2);
    let x=lastX+Math.floor(Math.random()*2+2)*BLOCK_SIZE;
    let y=lastY+(Math.floor(Math.random()*3)-1)*BLOCK_SIZE;
    y=Math.max(BLOCK_SIZE, Math.min(canvas.height-3*BLOCK_SIZE, y));

    for(let i=0;i<blockCount;i++){
        if(blocksPerColor>=3){
            rainbowIndex=(rainbowIndex+1)%rainbowColors.length;
            blocksPerColor=0;
        }
        blocksPerColor++;
        platforms.push({x:x+i*BLOCK_SIZE,y,width:BLOCK_SIZE,height:BLOCK_SIZE,color:rainbowColors[rainbowIndex]});
        if(Math.random()<0.05) spikes.push({x:x+i*BLOCK_SIZE+BLOCK_SIZE*0.2,y:y-BLOCK_SIZE+BLOCK_SIZE*0.2,width:BLOCK_SIZE*0.6,height:BLOCK_SIZE*0.6});
    }
    return {x:x+blockCount*BLOCK_SIZE,y};
}

function checkSpikeCollision(spike){
    const hbW=player.width*player.hitboxScale;
    const hbH=player.height*player.hitboxScale;
    const hbX=player.x+(player.width-hbW)/2;
    const hbY=player.y+(player.height-hbH)/2;
    return hbX+hbW>spike.x && hbX<spike.x+spike.width && hbY+hbH>spike.y && hbY<spike.y+spike.height;
}

function drawSupports(camX){
    for(let plat of platforms){
        ctx.strokeStyle="#fff"; ctx.lineWidth=4;
        let supportCount=Math.floor(plat.width/BLOCK_SIZE);
        for(let i=0;i<=supportCount;i++){
            let sx=plat.x+i*BLOCK_SIZE - camX;
            let sy=plat.y+plat.height;
            let groundY=canvas.height-10;
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx, groundY);
            ctx.stroke();
        }
    }
}

function createCrash(){
    const pieceCount=20;
    for(let i=0;i<pieceCount;i++){
        crashPieces.push({
            x:player.x+Math.random()*player.width,
            y:player.y+Math.random()*player.height,
            vx:(Math.random()-0.5)*15,
            vy:(Math.random()-1)*15,
            size:Math.random()*player.width/4+5,
            color:player.color
        });
    }
}

function spawnParticles(x,y,type){
    const color = type==="jump"?"#0ff":type==="double"?"#ff0":"#fff";
    for(let i=0;i<15;i++){
        particles.push({x,y,vx:(Math.random()-0.5)*5,vy:(Math.random()-1.5)*5,life:Math.random()*30+20,color});
    }
}

function drawCombinedOutline(camX){
    let points=[];
    platforms.forEach(p=>{
        points.push([p.x-camX,p.y],[p.x+p.width-camX,p.y],[p.x+p.width-camX,p.y+p.height],[p.x-camX,p.y+p.height]);
        let supportCount=Math.floor(p.width/BLOCK_SIZE);
        for(let i=0;i<=supportCount;i++){
            let sx=p.x+i*BLOCK_SIZE-camX, sy=p.y+p.height;
            points.push([sx,canvas.height-10]);
        }
    });
    if(points.length<3) return;
    points.sort((a,b)=>a[0]-b[0] || a[1]-b[1]);
    let hull=[];
    function cross(o,a,b){return (a[0]-o[0])*(b[1]-o[1])-(a[1]-o[1])*(b[0]-o[0]);}
    for(let i=0;i<points.length;i++){
        while(hull.length>=2 && cross(hull[hull.length-2],hull[hull.length-1],points[i])<=0) hull.pop();
        hull.push(points[i]);
    }
    let t=points.length; for(let i=points.length-2;i>=0;i--){
        while(hull.length>t && cross(hull.length-2,hull.length-1,points[i])<=0) hull.pop();
        hull.push(points[i]);
    }
    ctx.strokeStyle="#fff"; ctx.lineWidth=3;
    ctx.beginPath();
    ctx.moveTo(hull[0][0],hull[0][1]);
    for(let i=1;i<hull.length;i++) ctx.lineTo(hull[i][0],hull[i][1]);
    ctx.closePath(); ctx.stroke();
}

function tryDie(){
    if(player.onGround || player.vy>0) {createCrash(); gameStarted=false;}
}

function showStartScreen(){document.getElementById("startScreen").style.display="flex";}
function hideStartScreen(){document.getElementById("startScreen").style.display="none";}

function update(time){
    let delta=(time-lastTime)/1000; lastTime=time;

    // Gradually increase speed
    if(gameStarted) player.speed+=0.0001;

    // Camera follows player both horizontally and vertically
    let camX=player.x-150;
    let camY=player.y-150;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Score
    ctx.fillStyle="#fff"; ctx.font="40px sans-serif";
    ctx.fillText(Math.floor(score),20,50);

    if(gameStarted){
        player.y+=player.vy; player.vy+=GRAVITY;
        player.x+=player.speed;

        // Platform collision
        player.onGround=false;
        for(let plat of platforms){
            if(player.x+player.width>plat.x && player.x<plat.x+plat.width &&
               player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
                if(player.vy>=0){
                    player.y=plat.y-player.height; player.vy=0; player.onGround=true; player.jumpsLeft=2;
                    spawnParticles(player.x+player.width/2, player.y+player.height, "land");
                }
            }
        }
        if(player.y>canvas.height) {player.jumpsLeft=1; tryDie();}

        // Draw platforms
        for(let plat of platforms){
            ctx.fillStyle=plat.color; 
            ctx.fillRect(plat.x-camX,plat.y-camY,plat.width,plat.height);
        }

        drawSupports(camX);
        drawCombinedOutline(camX);

        // Spikes
        for(let spike of spikes){
            ctx.fillStyle="red"; ctx.beginPath();
            ctx.moveTo(spike.x-camX,spike.y+spike.height-camY);
            ctx.lineTo(spike.x-camX+spike.width/2,spike.y-camY);
            ctx.lineTo(spike.x-camX+spike.width,spike.y+spike.height-camY);
            ctx.closePath(); ctx.fill();
            if(checkSpikeCollision(spike)) tryDie();
        }

        // Draw player
        ctx.shadowColor="#0ff"; ctx.shadowBlur=20;
        ctx.fillStyle=player.color; ctx.fillRect(player.x-camX,player.y-camY,player.width,player.height);
        ctx.strokeStyle="#fff"; ctx.lineWidth=2;
        ctx.strokeRect(player.x-camX,player.y-camY,player.width,player.height);
        ctx.shadowBlur=0;

        let last=platforms[platforms.length-1];
        if(last.x<player.x+canvas.width) generateBlockPlatform(last.x,last.y);

        score+=delta*100;
    }

    // Crash pieces
    for(let i=crashPieces.length-1;i>=0;i--){
        let p=crashPieces[i];
        p.vy+=GRAVITY*0.5;
        p.x+=p.vx; p.y+=p.vy;
        ctx.fillStyle=p.color; ctx.fillRect(p.x-camX,p.y-camY,p.size,p.size);
        if(p.y>canvas.height) crashPieces.splice(i,1);
    }

    // Particles
    for(let i=particles.length-1;i>=0;i--){
        let p=particles[i];
        p.x+=p.vx; p.y+=p.vy; p.life--;
        ctx.fillStyle=p.color; ctx.globalAlpha=p.life/50; ctx.fillRect(p.x-camX,p.y-camY,5,5); ctx.globalAlpha=1;
        if(p.life<=0) particles.splice(i,1);
    }

    if(!gameStarted && crashPieces.length===0) showStartScreen();
    animationId=requestAnimationFrame(update);
}

document.getElementById("startBtn").addEventListener("click", ()=>{resetGame();});
showStartScreen();
</script>
</body>
</html>
