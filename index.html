<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fancy Platformer</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: sans-serif;
    color: white;
  }
  canvas {
    display: block;
  }
  #ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    text-align: center;
    pointer-events: none;
  }
  #startScreen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    pointer-events: all;
    font-size: 30px;
  }
  button {
    font-size: 24px;
    padding: 10px 20px;
    cursor: pointer;
    margin-top: 20px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">Start Game</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let gravity = 0.7;
let keys = {};
let score = 0;
let bestScore = 0;
let lastTime = 0;
let gameStarted = false;

// Player
let player = {
    x: 100,
    y: 300,
    width: 50,
    height: 50,
    color: "#0ff",
    vy: 0,
    speed: 5 // faster starting speed
};

// Particles
let particles = [];

// Platforms and spikes
let platforms = [];
let spikes = [];

// Key handling
window.addEventListener("keydown", (e) => keys[e.code] = true);
window.addEventListener("keyup", (e) => keys[e.code] = false);

// Particle effect
function createParticles(x, y, color) {
    for (let i = 0; i < 20; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: Math.random() * -5 - 2,
            size: Math.random() * 5 + 2,
            color: color,
            alpha: 1
        });
    }
}

// Generate platform dynamically based on last platform
function generatePlatform(lastX, lastY) {
    let width = Math.random() * 200 + 100;
    let height = 20;
    let x = lastX + Math.random() * 300 + 150;
    let y = lastY + (Math.random() - 0.5) * 200;
    y = Math.max(50, Math.min(canvas.height - 100, y));
    platforms.push({x, y, width, height, color: "#0f0"});

    if (Math.random() > 0.5 && width > 120) {
        let spikeX = x + Math.random() * (width - 20);
        spikes.push({x: spikeX, y: y - 20, width: 20, height: 20});
    }

    return {x, y};
}

// Reset game
function resetGame() {
    score = 0;
    player.x = 100;
    player.y = 300;
    player.vy = 0;
    player.speed = 5;
    platforms = [];
    spikes = [];
    particles = [];
    lastPlatform = generatePlatform(0, canvas.height/2);
}

// Death
function die() {
    createParticles(player.x + player.width/2, player.y + player.height/2, "#0ff");
    if (score > bestScore) bestScore = Math.floor(score);
    document.getElementById("bestScore").innerText = "Best Score: " + bestScore;
    showStartScreen();
    gameStarted = false;
}

// Show start screen
function showStartScreen() {
    document.getElementById("startScreen").style.display = "flex";
}

// Hide start screen
function hideStartScreen() {
    document.getElementById("startScreen").style.display = "none";
}

// Game loop
function update(time) {
    if (!gameStarted) return requestAnimationFrame(update);

    let delta = (time - lastTime) / 1000;
    lastTime = time;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update score
    score += delta * 100;
    ctx.fillStyle = "#fff";
    ctx.font = "30px sans-serif";
    ctx.fillText(Math.floor(score), 20, 40);

    // Player physics
    if ((keys["KeyW"] || keys["ArrowUp"] || keys["Space"]) && player.vy === 0) {
        player.vy = -15;
    }
    player.vy += gravity;
    player.y += player.vy;

    // Move forward and accelerate slowly
    player.x += player.speed;
    player.speed += 0.0005;

    let camX = player.x - 150;

    // Platform collision
    let onGround = false;
    for (let plat of platforms) {
        if (player.x + player.width > plat.x && player.x < plat.x + plat.width &&
            player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy) {
            player.y = plat.y - player.height;
            player.vy = 0;
            onGround = true;
        }
    }
    if (!onGround && player.y > canvas.height) die();

    // Draw platforms
    for (let plat of platforms) {
        ctx.fillStyle = plat.color;
        ctx.fillRect(plat.x - camX, plat.y, plat.width, plat.height);
    }

    // Draw spikes
    for (let spike of spikes) {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.moveTo(spike.x - camX, spike.y + spike.height);
        ctx.lineTo(spike.x - camX + spike.width/2, spike.y);
        ctx.lineTo(spike.x - camX + spike.width, spike.y + spike.height);
        ctx.closePath();
        ctx.fill();

        if (player.x + player.width > spike.x && player.x < spike.x + spike.width &&
            player.y + player.height > spike.y && player.y < spike.y + spike.height) {
            die();
        }
    }

    // Draw player
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - camX, player.y, player.width, player.height);

    // Particles
    for (let i = particles.length -1; i >=0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.5;
        p.alpha -= 0.02;
        ctx.fillStyle = `rgba(0,255,255,${p.alpha})`;
        ctx.fillRect(p.x - camX, p.y, p.size, p.size);
        if (p.alpha <=0) particles.splice(i,1);
    }

    // Generate new platforms dynamically
    let last = platforms[platforms.length-1];
    if (last.x < player.x + canvas.width) {
        generatePlatform(last.x, last.y);
    }

    requestAnimationFrame(update);
}

// Start button
document.getElementById("startBtn").addEventListener("click", () => {
    hideStartScreen();
    resetGame();
    gameStarted = true;
    lastTime = performance.now();
    requestAnimationFrame(update);
});

// Initial screen
showStartScreen();

</script>
</body>
</html>
