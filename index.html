<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bridd Jump</title>
<style>
body { margin:0; overflow:hidden; background:black; font-family:sans-serif; }
canvas { display:block; }
#ui { position:absolute; top:0; left:0; width:100%; height:100%; text-align:center; pointer-events:none; }
#startScreen {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    width:400px; padding:40px; background:rgba(0,0,0,0.9);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    pointer-events:all; font-size:30px; color:#0ff; text-shadow:0 0 20px #0ff;
    border:3px solid #0ff; border-radius:20px;
}
button { font-size:32px; padding:15px 40px; cursor:pointer; margin-top:30px; color:#0ff; background:black; border:3px solid #0ff; border-radius:12px; transition:0.3s; }
button:hover { color:black; background:#0ff; }
h1 { font-size:60px; margin-bottom:20px; text-shadow: 0 0 20px #0ff, 0 0 40px #0ff, 0 0 60px #0ff; animation: glow 1.5s infinite alternate; }
@keyframes glow { 0% { text-shadow:0 0 10px #0ff,0 0 20px #0ff;} 100% {text-shadow:0 0 40px #0ff,0 0 80px #0ff;} }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div id="startScreen">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn">START</button>
  </div>
</div>
<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

const BLOCK_SIZE=50;
const JUMP_SPEED=-15;
const GRAVITY=0.7;

let keys={}, score=0, bestScore=0, lastTime=0, gameStarted=false, animationId=null;
let crashPieces=[], particles=[], playerTrail=[];
let baseColors=[{r:255,g:0,b:0},{r:255,g:153,b:0},{r:255,g:255,b:0},{r:0,g:255,g:0},{r:0,g:255,b:255},{r:0,g:0,b:255},{r:153,g:0,b:255}];
let colorIndex=0, platformColor={r:255,g:0,b:0}, nextColor=baseColors[1], colorLerp=0;
let globalTime=0;

let player={
    x:100, y:0, width:50, height:50,
    color:"#0ff", vy:0, speed:15,
    hitboxScale:0.6, jumpsLeft:1, onGround:false, visible:true
};

let platforms=[], spikes=[], lines=[], gems=[], ground=[];

// Input
window.addEventListener("keydown", e=>{ if(["KeyW","ArrowUp","Space"].includes(e.code)) jump(); keys[e.code]=true; });
window.addEventListener("keyup", e=>keys[e.code]=false);
window.addEventListener("mousedown", ()=>jump());
window.addEventListener("touchstart", ()=>jump());

function jump(){
    if(!player.visible) return;
    if(player.jumpsLeft>0){
        player.vy=JUMP_SPEED;
        spawnParticles(player.x+player.width/2, player.y+player.height, player.jumpsLeft===2?"jump":"double");
        playerTrail.push({x:player.x+player.width/2, y:player.y+player.height/2, life:20});
        player.jumpsLeft--;
    }
}

function resetGame(){
    if(animationId) cancelAnimationFrame(animationId);
    score=0; colorLerp=0; globalTime=0;
    player.x=100; player.y=canvas.height/2-player.height; player.vy=0; player.speed=15;
    player.jumpsLeft=1; player.onGround=false; player.visible=true;

    platforms=[]; spikes=[]; crashPieces=[]; particles=[]; lines=[]; gems=[]; ground=[]; playerTrail=[];

    platformColor={...baseColors[0]}; colorIndex=0; nextColor=baseColors[1];

    platforms.push({x:0,y:player.y+player.height,width:BLOCK_SIZE*10,height:BLOCK_SIZE,color:{...platformColor},passed:false});
    ground.push({x:0,y:canvas.height-BLOCK_SIZE,width:canvas.width*10,height:BLOCK_SIZE,color:{r:50,g:50,b:50}});

    lastTime=performance.now();
    hideStartScreen();
    gameStarted=true;
    update(lastTime);
}

function generateBlockPlatform(lastX,lastY){
    let blockCount=Math.floor(Math.random()*8)+1; if(Math.random()<0.7) blockCount=Math.min(blockCount,Math.floor(Math.random()*3+1));
    let gap=Math.floor(Math.random()*5+3)*BLOCK_SIZE;
    let x=lastX+gap; let y=lastY+(Math.floor(Math.random()*3)-1)*BLOCK_SIZE;
    y=Math.max(BLOCK_SIZE, Math.min(canvas.height-3*BLOCK_SIZE, y));
    for(let i=0;i<blockCount;i++){
        platforms.push({x:x+i*BLOCK_SIZE,y,width:BLOCK_SIZE,height:BLOCK_SIZE,color:{...platformColor}, passed:false});
        if(Math.random()<0.1) spikes.push({x:x+i*BLOCK_SIZE+BLOCK_SIZE*0.2,y:y-BLOCK_SIZE+BLOCK_SIZE*0.2,width:BLOCK_SIZE*0.6,height:BLOCK_SIZE*0.6, baseY:y-BLOCK_SIZE+BLOCK_SIZE*0.2, hit:true, passed:false});
        if(Math.random()<0.08) gems.push({x:x+i*BLOCK_SIZE+BLOCK_SIZE*0.25, y:y-BLOCK_SIZE*0.5, size:BLOCK_SIZE*0.5, collected:false, glow:0});
    }
    return {x:x+blockCount*BLOCK_SIZE,y};
}

function checkSpikeCollision(spike){
    if(!spike.hit) return false;
    const hbW=player.width*player.hitboxScale;
    const hbH=player.height*player.hitboxScale;
    const hbX=player.x+(player.width-hbW)/2;
    const hbY=player.y+(player.height-hbH)/2;
    return hbX+hbW>spike.x && hbX<spike.x+spike.width && hbY+hbH>spike.y && hbY<spike.y+spike.height;
}

function createCrash(){
    const pieceCount=25;
    for(let i=0;i<pieceCount;i++){
        crashPieces.push({x:player.x+Math.random()*player.width,y:player.y+Math.random()*player.height,vx:(Math.random()-0.5)*20,vy:(Math.random()-1)*20,size:Math.random()*player.width/4+5,color:player.color});
    }
}

function spawnParticles(x,y,type){
    const color = type==="jump"?"#0ff":type==="double"?"#ff0":"#fff";
    for(let i=0;i<20;i++) particles.push({x,y,vx:(Math.random()-0.5)*7,vy:(Math.random()-1.5)*7,life:Math.random()*30+20,color});
}

function tryDie(spike){
    if(!player.visible) return;
    if(player.onGround || player.vy>0){
        player.visible=false;
        if(spike) spike.hit=false;
        createCrash();
        gameStarted=false;
        if(score>bestScore) bestScore=Math.floor(score);
    }
}

function showStartScreen(){ 
    document.getElementById("bestScore").innerText="Best Score: "+bestScore;
    document.getElementById("startScreen").style.display="flex"; 
}
function hideStartScreen(){document.getElementById("startScreen").style.display="none";}

function addLine(){ 
    if(Math.random()>0.2) return;
    lines.push({x:canvas.width, y:Math.random()*canvas.height, width:Math.random()*80+20, speed:(player.speed+5)*5, blur:Math.random()*10}); 
}

function lerpColor(c1,c2,t){return {r:c1.r+(c2.r-c1.r)*t, g:c1.g+(c2.g-c1.g)*t, b:c1.b+(c2.b-c1.b)*t};}
function rgb(c){return `rgb(${Math.floor(c.r)},${Math.floor(c.g)},${Math.floor(c.b)})`; }

function update(time){
    let delta=(time-lastTime)/1000; lastTime=time;
    globalTime+=delta;

    if(gameStarted && player.visible){
        player.speed+=0.005;
        colorLerp+=delta/10;
        if(colorLerp>=1){ colorIndex=(colorIndex+1)%baseColors.length; nextColor=baseColors[(colorIndex+1)%baseColors.length]; colorLerp=0; }
        platformColor=lerpColor(baseColors[colorIndex],nextColor,colorLerp);

        player.y+=player.vy; player.vy+=GRAVITY;
        player.x+=player.speed;

        player.onGround=false;
        for(let plat of platforms){
            if(player.x+player.width>plat.x && player.x<plat.x+plat.width &&
               player.y+player.height>plat.y && player.y+player.height<plat.y+plat.height+player.vy){
                if(player.vy>=0){ player.y=plat.y-player.height; player.vy=0; player.onGround=true; player.jumpsLeft=2; spawnParticles(player.x+player.width/2, player.y+player.height,"land"); }
            }
        }

        for(let spike of spikes){
            if(checkSpikeCollision(spike)) tryDie(spike);
            if(!spike.passed && player.x>spike.x+spike.width){score++; spike.passed=true;}
        }

        for(let gem of gems){
            if(!gem.collected && player.x+player.width>gem.x && player.x<gem.x+gem.size && player.y+player.height>gem.y && player.y<gem.y+gem.size){
                gem.collected=true; score+=50; for(let i=0;i<25;i++) particles.push({x:gem.x+gem.size/2,y:gem.y+gem.size/2,vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,life:40+Math.random()*20,color:"#fff"});}
            if(!gem.collected) gem.glow+=delta*5;
        }

        let lastPlatform = platforms[platforms.length-1];
        if(lastPlatform.x < player.x + canvas.width) generateBlockPlatform(lastPlatform.x, lastPlatform.y);
        addLine();
    }

    const targetCamX=player.x-150;
    const targetCamY=player.y - canvas.height/2 + player.height*1.5;
    cameraX = (typeof cameraX!=='undefined'?cameraX:targetCamX)*0.9 + targetCamX*0.1;
    cameraY = (typeof cameraY!=='undefined'?cameraY:targetCamY)*0.9 + targetCamY*0.1;

    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle="#fff"; ctx.font="40px sans-serif"; ctx.fillText(score,20,50);

    // Ground
    for(let g of ground){ctx.fillStyle=`rgb(${g.color.r},${g.color.g},${g.color.b})`; ctx.fillRect(g.x-cameraX,g.y-cameraY,g.width,g.height);}

    // Platforms
    for(let plat of platforms){ctx.shadowColor=plat.color; ctx.shadowBlur=20; ctx.fillStyle=rgb(platformColor); ctx.fillRect(plat.x-cameraX, plat.y-cameraY, plat.width, plat.height); ctx.shadowBlur=0;}

    // Spikes
    for(let spike of spikes){ let pulse = Math.sin(globalTime*5 + spike.x)*5; ctx.fillStyle="red"; ctx.beginPath(); ctx.moveTo(spike.x-cameraX,spike.baseY+spike.height-cameraY+pulse); ctx.lineTo(spike.x-cameraX+spike.width/2,spike.baseY-cameraY+pulse); ctx.lineTo(spike.x-cameraX+spike.width,spike.baseY+spike.height-cameraY+pulse); ctx.closePath(); ctx.fill(); }

    // Gems
    for(let gem of gems){
        if(gem.collected) continue;
        ctx.save(); ctx.translate(gem.x+gem.size/2-cameraX, gem.y+gem.size/2-cameraY); ctx.rotate(Math.PI/4);
        ctx.shadowBlur=20*Math.sin(gem.glow); ctx.shadowColor="#fff"; ctx.fillStyle="#fff"; ctx.fillRect(-gem.size/2,-gem.size/2,gem.size,gem.size); ctx.shadowBlur=0; ctx.restore();
    }

    // Player trail
    for(let i=playerTrail.length-1;i>=0;i--){ let p=playerTrail[i]; p.life--; ctx.fillStyle="rgba(0,255,255,"+p.life/20+")"; ctx.fillRect(p.x-cameraX,p.y-cameraY,player.width/2,player.height/2); if(p.life<=0) playerTrail.splice(i,1);}

    // Player
    if(player.visible){ ctx.shadowColor="#0ff"; ctx.shadowBlur=30; ctx.fillStyle=player.color; ctx.fillRect(player.x-cameraX,player.y-cameraY,player.width,player.height); ctx.strokeStyle="#fff"; ctx.lineWidth=8; ctx.strokeRect(player.x-cameraX,player.y-cameraY,player.width,player.height); ctx.shadowBlur=0;}

    // Horizontal lines
    for(let i=lines.length-1;i>=0;i--){ let line=lines[i]; line.x -= line.speed*5; ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.lineWidth=Math.random()*3+1; ctx.beginPath(); ctx.moveTo(line.x,line.y); ctx.lineTo(line.x+line.width,line.y); ctx.stroke(); if(line.x+line.width<0) lines.splice(i,1); }

    // Crash pieces
    for(let i=crashPieces.length-1;i>=0;i--){ let p=crashPieces[i]; p.vy+=GRAVITY*0.5; p.x+=p.vx; p.y+=p.vy; ctx.fillStyle=p.color; ctx.fillRect(p.x-cameraX,p.y-cameraY,p.size,p.size); if(p.y>canvas.height) crashPieces.splice(i,1); }

    // Particles
    for(let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; ctx.fillStyle=p.color; ctx.globalAlpha=p.life/50; ctx.fillRect(p.x-cameraX,p.y-cameraY,5,5); ctx.globalAlpha=1; if(p.life<=0) particles.splice(i,1); }

    if(!gameStarted && crashPieces.length===0) showStartScreen();
    animationId=requestAnimationFrame(update);
}

document.getElementById("startBtn").addEventListener("click", ()=>{resetGame();});
showStartScreen();
</script>
</body>
</html>
