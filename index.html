<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bridd Jump</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; margin:0 auto; background:#000; }
  #menu {
    position:absolute;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    color:white;
    font-family:sans-serif;
    text-align:center;
    display:none;
  }
  #menu button {
    background:#111; color:#fff;
    border:2px solid white;
    padding:10px 20px; margin-top:10px;
    font-size:20px; cursor:pointer;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="menu">
  <h1>Bridd Jump</h1>
  <p id="scoreDisplay">Score: 0</p>
  <p id="bestScoreDisplay">Best Score: 0</p>
  <button id="startBtn">START</button>
</div>
<script>
const canvas=document.getElementById("gameCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

let GRAVITY=0.8;
let JUMP=-15;
let doubleJumpAvailable=true;
let gameStarted=false;
let score=0, bestScore=0;

let camera={x:0,y:0};
let playerAnim="walk"; // walk | jump | doublejump
let animFrame=0;

let player={
  x:200,y:200,w:30,h:40,
  vy:0,speed:6,visible:true
};

let platforms=[];
let strikes=[];
let gems=[];
let particles=[];
let lines=[];
let torches=[];

let baseColors=["#ff0000","#ff7f00","#ffff00","#00ff00","#0000ff","#4b0082","#8f00ff"];
let colorIndex=0, nextColor=baseColors[1], colorLerp=0;
let platformColor="#fff";
const blockSize=40;
const groundY=500;

function resetGame(){
  score=0;
  player.x=200; player.y=200;
  player.vy=0;
  player.speed=6;
  player.visible=true;
  playerAnim="walk";
  animFrame=0;
  doubleJumpAvailable=true;
  platforms=[]; strikes=[]; gems=[]; particles=[]; lines=[]; torches=[];
  generateGround();
  generateInitialPlatforms();
}

function generateGround(){
  for(let i=0;i<200;i++){
    let gx=i*blockSize;
    platforms.push({x:gx,y:groundY,w:blockSize,h:20,ground:true});
    strikes.push({x:gx,y:groundY-40,w:40,h:40}); // strike above every ground block
  }
}

function generateInitialPlatforms(){
  for(let i=0;i<10;i++){
    platforms.push({x:i*blockSize,y:groundY-120,w:blockSize,h:20});
  }
}

function spawnPlatform(){
  let gap=Math.random()<0.5?80:120;
  let last=platforms[platforms.length-1];
  let len=Math.floor(Math.random()*8)+1;
  let py=groundY-Math.floor(Math.random()*6+2)*blockSize;
  for(let i=0;i<len;i++){
    platforms.push({x:last.x+gap+i*blockSize,y:py,w:blockSize,h:20});
  }
  // ensure no gem and strike too close
  if(Math.random()<0.3){
    strikes.push({x:last.x+gap+Math.random()*len*blockSize,y:py-40,w:40,h:40});
  } else if(Math.random()<0.2){
    gems.push({x:last.x+gap+Math.random()*len*blockSize,y:py-60,w:20,h:20});
  }
  // add torch randomly on wall
  if(Math.random()<0.1){
    torches.push({x:last.x+gap+Math.random()*len*blockSize,y:py-100});
  }
}

function drawPlayer(){
  if(!player.visible)return;
  ctx.save();
  ctx.translate(player.x-camera.x,player.y-camera.y);

  ctx.fillStyle="cyan";

  if(playerAnim==="walk"){
    // body
    ctx.fillRect(-10,-20,20,20);
    // legs alternating
    if(Math.floor(animFrame/10)%2===0){
      ctx.fillRect(-10,0,8,20);
      ctx.fillRect(2,0,8,10);
    }else{
      ctx.fillRect(-10,0,8,10);
      ctx.fillRect(2,0,8,20);
    }
    // head
    ctx.fillStyle="white";
    ctx.fillRect(-8,-32,16,12);
  }
  else if(playerAnim==="jump"){
    ctx.fillRect(-10,-20,20,20);
    ctx.fillRect(-6,0,12,12);
    ctx.fillStyle="white";
    ctx.fillRect(-8,-32,16,12);
  }
  else if(playerAnim==="doublejump"){
    ctx.rotate(animFrame/5);
    ctx.fillRect(-10,-20,20,20);
    ctx.fillStyle="white";
    ctx.fillRect(-8,-32,16,12);
  }

  ctx.restore();
}

function drawPlatforms(){
  ctx.fillStyle=platformColor;
  platforms.forEach(p=>{
    if(p.y<=groundY-2*blockSize || p.ground){ // not below ground+2
      ctx.save();
      if(!p.ground){
        ctx.shadowColor=platformColor;
        ctx.shadowBlur=20;
      }
      ctx.fillRect(p.x-camera.x,p.y-camera.y,p.w,p.h);
      ctx.restore();
    }
  });
}

function drawStrikes(){
  ctx.fillStyle="red";
  strikes.forEach(s=>{
    ctx.save();
    ctx.shadowColor="red";
    ctx.shadowBlur=15;
    ctx.fillRect(s.x-camera.x,s.y-camera.y,s.w,s.h);
    ctx.restore();
  });
}

function drawGems(){
  gems.forEach(g=>{
    ctx.save();
    ctx.translate(g.x-camera.x+g.w/2,g.y-camera.y+g.h/2);
    ctx.rotate(Math.PI/4);
    ctx.fillStyle="white";
    ctx.shadowColor="white";
    ctx.shadowBlur=20;
    ctx.fillRect(-g.w/2,-g.h/2,g.w,g.h);
    ctx.restore();
  });
}

function drawTorches(){
  torches.forEach(t=>{
    ctx.save();
    ctx.fillStyle="orange";
    ctx.shadowColor="orange";
    ctx.shadowBlur=30+Math.sin(Date.now()/100+t.x)*10;
    ctx.fillRect(t.x-camera.x,t.y-camera.y,10,30);
    ctx.restore();
  });
}

function drawLines(){
  ctx.strokeStyle="rgba(255,255,255,0.15)";
  ctx.lineWidth=2;
  lines.forEach(l=>{
    ctx.beginPath();
    ctx.moveTo(l.x-camera.x,l.y-camera.y);
    ctx.lineTo(l.x+canvas.width-camera.x,l.y-camera.y);
    ctx.stroke();
  });
}

function update(){
  if(gameStarted&&player.visible){
    player.speed += 0.08;
    animFrame++;

    colorLerp+=0.001;
    if(colorLerp>=1){
      colorIndex=(colorIndex+1)%baseColors.length;
      nextColor=baseColors[(colorIndex+1)%baseColors.length];
      colorLerp=0;
    }
    platformColor=lerpColor(baseColors[colorIndex],nextColor,colorLerp);

    player.y+=player.vy;
    player.vy+=GRAVITY;
    player.x+=player.speed;

    camera.x=player.x-canvas.width/3;
    camera.y=player.y-canvas.height/2.5;

    if(platforms[platforms.length-1].x<player.x+canvas.width){
      spawnPlatform();
    }

    let onGround=false;
    platforms.forEach(p=>{
      if(player.x+player.w/2>p.x&&player.x-player.w/2<p.x+p.w&&
         player.y+player.h/2>p.y&&player.y+player.h/2<p.y+p.h){
        player.y=p.y-player.h/2;
        player.vy=0;
        doubleJumpAvailable=true;
        onGround=true;
        score+=1;
      }
    });

    if(onGround) playerAnim="walk";
    else if(playerAnim!=="doublejump") playerAnim="jump";

    strikes.forEach((s,i)=>{
      if(player.x+player.w/2>s.x&&player.x-player.w/2<s.x+s.w&&
         player.y+player.h/2>s.y&&player.y-player.h/2<s.y+s.h){
        explodePlayer();
      }
      if(s.x+s.w<player.x){
        score+=1; strikes.splice(i,1);
      }
    });

    gems.forEach((g,i)=>{
      if(player.x+player.w/2>g.x&&player.x-player.w/2<g.x+g.w&&
         player.y+player.h/2>g.y&&player.y-player.h/2<g.y+g.h){
        score+=50; explodeGem(g.x,g.y); gems.splice(i,1);
      }
    });

    if(Math.random()<0.05){
      lines.push({x:camera.x+canvas.width,y:Math.random()*canvas.height});
    }
    lines.forEach(l=>{l.x-=player.speed*2;});
    lines=lines.filter(l=>l.x+canvas.width>camera.x);

    particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life--;});
    particles=particles.filter(p=>p.life>0);
  }
}

function explodePlayer(){
  player.visible=false;
  for(let i=0;i<30;i++){
    particles.push({x:player.x,y:player.y,
      vx:(Math.random()-0.5)*10,vy:(Math.random()-0.5)*10,
      life:60,color:"cyan"});
  }
  setTimeout(()=>{
    document.getElementById("menu").style.display="block";
    document.getElementById("scoreDisplay").textContent="Score: "+score;
    if(score>bestScore)bestScore=score;
    document.getElementById("bestScoreDisplay").textContent="Best Score: "+bestScore;
    gameStarted=false;
  },1000);
}

function explodeGem(x,y){
  for(let i=0;i<15;i++){
    particles.push({x,y,
      vx:(Math.random()-0.5)*6,vy:(Math.random()-0.5)*6,
      life:40,color:"white"});
  }
}

function drawParticles(){
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x-camera.x,p.y-camera.y,4,4);
  });
}

function lerpColor(a,b,t){
  let ar=parseInt(a.substr(1,2),16);
  let ag=parseInt(a.substr(3,2),16);
  let ab=parseInt(a.substr(5,2),16);
  let br=parseInt(b.substr(1,2),16);
  let bg=parseInt(b.substr(3,2),16);
  let bb=parseInt(b.substr(5,2),16);
  let rr=Math.floor(ar+(br-ar)*t);
  let rg=Math.floor(ag+(bg-ag)*t);
  let rb=Math.floor(ab+(bb-ab)*t);
  return `rgb(${rr},${rg},${rb})`;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawLines();
  drawPlatforms();
  drawStrikes();
  drawGems();
  drawTorches();
  drawPlayer();
  drawParticles();
  requestAnimationFrame(draw);
}

document.getElementById("startBtn").onclick=()=>{
  document.getElementById("menu").style.display="none";
  resetGame();
  gameStarted=true;
};

document.addEventListener("keydown",e=>{
  if(!gameStarted||!player.visible)return;
  if(e.code==="Space"||e.code==="ArrowUp"||e.code==="KeyW"){
    if(player.vy===0){
      player.vy=JUMP; playerAnim="jump"; doubleJumpAvailable=true;
    }else if(doubleJumpAvailable){
      player.vy=JUMP; playerAnim="doublejump"; doubleJumpAvailable=false;
    }
  }
});
document.addEventListener("click",()=>{
  if(!gameStarted||!player.visible)return;
  if(player.vy===0){
    player.vy=JUMP; playerAnim="jump"; doubleJumpAvailable=true;
  }else if(doubleJumpAvailable){
    player.vy=JUMP; playerAnim="doublejump"; doubleJumpAvailable=false;
  }
});

function gameLoop(){update();setTimeout(gameLoop,1000/60);}
gameLoop();
draw();
</script>
</body>
</html>
