<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bridd Jump</title>
<style>
  body { margin:0; background:black; overflow:hidden; }
  canvas { display:block; margin:0 auto; background:#111; }
  #commandOverlay {
    position: fixed;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    border: 2px solid #0f0;
    padding: 20px;
    z-index: 9999;
    display: none;
  }
  #commandInput {
    width: 400px;
    font-size: 18px;
    padding: 5px;
    background:black;
    color:#0f0;
    border:1px solid #0f0;
  }
</style>
</head>
<body>
<canvas id="gameCanvas" width="960" height="540"></canvas>
<div id="commandOverlay">
  <input type="text" id="commandInput" placeholder="Enter command here...">
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

// ==== GLOBALS ====
let score = 0;
let freezeScore = false;
let scoreFunctionMultiplier = 1;
let globalTime = 0;
let animationFrameId = null;
let gameStarted = false;
let testMode = false;
let floatEnabled = false;
let godMode = false;
let playerName = "Bridd";

// ==== PLAYER ====
const player = {
  x: canvas.width/2 - 20,
  y: canvas.height - 60,
  width: 40,
  height: 40,
  color: "#0f0",
  velocityX: 0,
  velocityY: 0,
  speed: 5,
  jumpForce: 15,
  grounded: false,
  gravity: 0.8,
  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
  },
  update() {
    if (floatEnabled) {
      this.velocityY *= 0.9;
    } else {
      this.velocityY += this.gravity;
    }
    this.y += this.velocityY;
    this.x += this.velocityX;
    if (this.x < 0) this.x = 0;
    if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
    if (this.y + this.height > canvas.height) {
      this.y = canvas.height - this.height;
      this.velocityY = 0;
      this.grounded = true;
    } else {
      this.grounded = false;
    }
    this.draw();
  }
};

// ==== PLATFORMS ====
let platforms = [];
function createPlatform(x, y, width, height) {
  return {x, y, width, height, color:"#555"};
}
function generatePlatforms() {
  platforms = [];
  const ground = createPlatform(0, canvas.height-20, canvas.width, 20);
  ground.color = "#0a0";
  platforms.push(ground);
  for (let i=0; i<10; i++) {
    let px = Math.random()* (canvas.width-100);
    let py = Math.random()* (canvas.height-100);
    platforms.push(createPlatform(px, py, 100, 15));
  }
}
function drawPlatforms() {
  for (let p of platforms) {
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x, p.y, p.width, p.height);
  }
}
function checkPlatformCollisions() {
  for (let p of platforms) {
    if (player.x < p.x + p.width &&
        player.x + player.width > p.x &&
        player.y + player.height > p.y &&
        player.y + player.height < p.y + p.height &&
        player.velocityY >= 0) {
      player.y = p.y - player.height;
      player.velocityY = 0;
      player.grounded = true;
    }
  }
}

// ==== SPIKES ====
let spikes = [];
function createSpike(x, y) {
  return {x, y, width:20, height:20, color:"red"};
}
function generateSpikes() {
  spikes = [];
  for (let i=0; i<5; i++) {
    let px = Math.random()*(canvas.width-20);
    let py = Math.random()*(canvas.height-60);
    spikes.push(createSpike(px, py));
  }
}
function drawSpikes() {
  for (let s of spikes) {
    ctx.fillStyle = s.color;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y+s.height);
    ctx.lineTo(s.x+s.width/2, s.y);
    ctx.lineTo(s.x+s.width, s.y+s.height);
    ctx.closePath();
    ctx.fill();
  }
}
function checkSpikeCollision() {
  for (let s of spikes) {
    if (player.x < s.x+s.width &&
        player.x+player.width > s.x &&
        player.y < s.y+s.height &&
        player.y+player.height > s.y) {
      if (!godMode) tryDie();
    }
  }
}

// ==== GEMS ====
let gems = [];
function createGem(x,y) {
  return {x,y,size:15,color:"#0ff",glow:1};
}
function generateGems() {
  gems = [];
  for (let i=0; i<5; i++) {
    let gx = Math.random()*(canvas.width-20);
    let gy = Math.random()*(canvas.height-100);
    gems.push(createGem(gx, gy));
  }
}
function drawGems() {
  for (let g of gems) {
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = g.color;
    ctx.fillStyle = g.color;
    ctx.beginPath();
    ctx.arc(g.x, g.y, g.size, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}
function checkGemCollection() {
  for (let i=gems.length-1; i>=0; i--) {
    let g = gems[i];
    if (player.x < g.x+g.size &&
        player.x+player.width > g.x &&
        player.y < g.y+g.size &&
        player.y+player.height > g.y) {
      score += 10;
      createGemCrash(g.x,g.y);
      gems.splice(i,1);
    }
  }
}

// ==== GEM EFFECTS ====
let particles = [];
function createGemCrash(x,y) {
  for (let i=0; i<20; i++) {
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*6,
      vy:(Math.random()-0.5)*6,
      life:60,
      color:"#0ff"
    });
  }
}
function updateParticles() {
  for (let i=particles.length-1; i>=0; i--) {
    let p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    ctx.save();
    ctx.globalAlpha = p.life/60;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x,p.y,3,3);
    ctx.restore();
    if (p.life<=0) particles.splice(i,1);
  }
}

// ==== CRASH / DEATH ====
let crashed = false;
function tryDie() {
  crashed = true;
  cancelAnimationFrame(animationFrameId);
  ctx.fillStyle="rgba(255,0,0,0.5)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="white";
  ctx.font="40px Arial";
  ctx.fillText("YOU DIED", canvas.width/2-100, canvas.height/2);
}

// ==== SCORE ====
function drawScore() {
  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText("Score: "+score, 20,30);
}

// ==== COMMANDS ====
const commandOverlay = document.getElementById("commandOverlay");
const commandInput = document.getElementById("commandInput");
function openCommandOverlay() {
  commandOverlay.style.display="block";
  commandInput.focus();
}
function closeCommandOverlay() {
  commandOverlay.style.display="none";
  commandInput.value="";
}
function executeCommand(cmd) {
  const parts = cmd.trim().split(" ");
  if (parts[0]==="/gamerule") {
    if (parts[1]==="speed") {
      if (parts[2]==="set") player.speed=parseFloat(parts[3]);
      if (parts[2]==="lanseyaoji") player.speed=10;
    }
    if (parts[1]==="score") {
      if (parts[2]==="add") score+=parseInt(parts[3]);
      if (parts[2]==="set") score=parseInt(parts[3]);
      if (parts[2]==="reset") score=0;
      if (parts[2]==="freeze") freezeScore=true;
      if (parts[2]==="function" && parts[3]==="+=") scoreFunctionMultiplier=parseFloat(parts[4]);
    }
  }
  if (parts[0]==="/control") {
    if (parts[1]==="freeze") cancelAnimationFrame(animationFrameId);
    if (parts[1]==="unfreeze") requestAnimationFrame(gameLoop);
  }
}
commandInput.addEventListener("keydown", e=>{
  if (e.key==="Enter") {
    executeCommand(commandInput.value);
    closeCommandOverlay();
  } else if (e.key==="Escape") {
    closeCommandOverlay();
  }
});

// ==== INPUT ====
const keys = {};
document.addEventListener("keydown", e=>{
  keys[e.code]=true;
  if (e.code==="KeyG") godMode=!godMode;
  if (e.ctrlKey && e.shiftKey && e.code==="KeyA") {
    e.preventDefault();
    openCommandOverlay();
  }
});
document.addEventListener("keyup", e=>{
  keys[e.code]=false;
});

// ==== GAME LOOP ====
function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  player.update();
  checkPlatformCollisions();
  drawPlatforms();
  drawSpikes();
  drawGems();
  checkSpikeCollision();
  checkGemCollection();
  updateParticles();
  drawScore();
  score += (!freezeScore ? 1*scoreFunctionMultiplier : 0);
}
function gameLoop() {
  update();
  animationFrameId=requestAnimationFrame(gameLoop);
}
function startGame() {
  generatePlatforms();
  generateSpikes();
  generateGems();
  gameStarted=true;
  gameLoop();
}
startGame();
</script>
</body>
</html>
