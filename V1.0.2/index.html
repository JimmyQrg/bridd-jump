<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bridd Jump - Enhanced</title>
<link rel="icon" href="infinite-campus.png">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root { --bg: #000; --accent: #0ff; --panel: rgba(0,0,0,0.9); --muted: #88f7ff; }
  * { box-sizing: border-box; }
  html, body { height:100%; margin:0; background:var(--bg); color:#fff; 
              font-family: "Press Start 2P", monospace; -webkit-font-smoothing: none; 
              -moz-osx-font-smoothing: grayscale; overflow: hidden; }
  canvas { display:block; position: absolute; top:0; left:0; width:100%; height:100%; 
           z-index:1; background: #000; image-rendering: pixelated; }
  #menu, #scoreHUD, #fpsLabel, #debugToast, #mobileCommandBtn { 
    position: absolute; pointer-events: none; }
  #menu { left:50%; top:50%; transform: translate(-50%, -50%); width: 460px; max-width: 94vw;
          padding: 28px; background: var(--panel); border: 4px solid var(--accent);
          border-radius: 12px; display:flex; flex-direction: column; align-items: center;
          gap: 12px; z-index: 1200; pointer-events: all; }
  #menu h1 { margin:0; font-size: 28px; color: var(--accent); 
             text-shadow: 0 0 12px var(--accent); }
  #bestScore { font-size: 12px; color: var(--muted); margin-top: 6px;}
  .btn { appearance:none; border:3px solid var(--accent); background:transparent;
          color:var(--accent); padding:12px 18px; border-radius:10px; cursor:pointer;
          font-size:12px; width:300px; text-align:center; pointer-events: all; }
  .btn:hover { background:var(--accent); color:#000; }
  #scoreHUD { left: 12px; top: 12px; z-index: 1100; font-size:12px; color:var(--accent);
              text-shadow:0 0 6px rgba(0,255,255,0.2); }
  #fpsLabel { left: 12px; top: 44px; z-index: 1100; font-size:11px; color:var(--accent); }
  #debugToast { left:50%; transform:translateX(-50%); bottom:18px; z-index:1300;
                background:rgba(0,0,0,0.6); border:2px solid var(--accent); 
                color:var(--accent); padding:8px 12px; border-radius:8px; display:none; 
                font-size:11px; }
  #mobileCommandBtn { right: 20px; bottom: 20px; width: 60px; height: 60px;
                     background: rgba(0, 255, 255, 0.1); border: 2px solid rgba(0, 255, 255, 0.3);
                     border-radius: 50%; z-index: 1000; opacity: 0.3; cursor: pointer;
                     pointer-events: all; }
  @media (max-width:560px){ #menu { width: 92vw; padding: 18px; }
    .btn { width: 100%; font-size:11px; padding:10px; } #menu h1 { font-size:20px; } }
</style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="menu" role="dialog" aria-label="start menu">
    <h1>BRIDD JUMP</h1>
    <div id="bestScore">Best Score: 0</div>
    <button id="startBtn" class="btn">START</button>
    <button id="settingsBtn" class="btn">SETTINGS</button>
  </div>
  <div id="scoreHUD">Score: 0</div>
  <div id="fpsLabel">FPS: --</div>
  <div id="debugToast"></div>
  <div id="mobileCommandBtn" title="Open Command (Ctrl+Shift+A)"></div>

<script>
// ========================================================
// ENHANCED BRIDD JUMP WITH FIXES & NEW EFFECTS
// ========================================================

/* ---------- CONFIGURATION & PRE-COMPUTATION ---------- */
const BLOCK_SIZE = 50;
const JUMP_SPEED = -15;
const GRAVITY = 0.7;
const TARGET_FPS = 60;
const TICK_INTERVAL = 1000 / TARGET_FPS;
const DELETE_OFFSET = BLOCK_SIZE * 6;
const MIN_KEEP_BLOCKS = 25;

// Pre-computed values
const HALF_BLOCK = BLOCK_SIZE * 0.5;
const BLOCK_QUARTER = BLOCK_SIZE * 0.25;

// Color cache
const BASE_COLORS = [
  [255,0,0], [255,153,0], [255,255,0],
  [0,255,0], [0,255,255], [0,0,255], [153,0,255]
];

/* ---------- SETTINGS LOADING (FIXED BLOCK TEXTURE LOGIC) ---------- */
let settings = {
  maxFPS: 0,
  qualityPreset: "Extreme+",
  quality: {
    jumpEffect: 64,
    walkEffect: 64,
    dieEffect: 64,
    horizontalLines: 64,
    trail: 64,
    blockTexture: true, // TRUE = TEXTURE ON, FALSE = TEXTURE OFF (FIXED)
    glow: 100,
    // NEW EFFECTS
    screenShake: 100,
    particlePhysics: 100,
    colorIntensity: 100,
    motionBlur: 0,
    afterImages: 0
  }
};

try {
  const saved = localStorage.getItem("briddSettings");
  if (saved) {
    const loaded = JSON.parse(saved);
    settings.maxFPS = loaded.maxFPS || 0;
    settings.qualityPreset = loaded.qualityPreset || "Extreme+";
    if (loaded.quality) {
      settings.quality = { ...settings.quality, ...loaded.quality };
      // Ensure boolean for blockTexture
      settings.quality.blockTexture = Boolean(loaded.quality.blockTexture);
    }
  }
} catch(e) { console.warn("Settings load failed:", e); }

/* ---------- RUNTIME SETTINGS ---------- */
let runtime = {
  minFrameTime: settings.maxFPS ? 1000 / settings.maxFPS : 0,
  blockTextureEnabled: settings.quality.blockTexture, // FIXED: true = texture ON
  screenShakeMul: settings.quality.screenShake / 100,
  particlePhysicsMul: settings.quality.particlePhysics / 100,
  colorIntensityMul: settings.quality.colorIntensity / 100,
  motionBlurEnabled: settings.quality.motionBlur > 50,
  afterImagesEnabled: settings.quality.afterImages > 50
};

/* ---------- GAME STATE ---------- */
const player = {
  x: 100, y: 0, width: 50, height: 50, vy: 0, speed: 11,
  color: "#0ff", hitboxScale: 0.6, jumpsLeft: 2, onGround: false, visible: true
};

let platforms = [], spikes = [], gems = [], particles = [], 
    crashPieces = [], trail = [], lines = [], afterImages = [];
let score = 0, bestScore = localStorage.getItem("bestScore")|0;
let gameRunning = false, cameraX = 0, cameraY = 0;
let colorIndex = 0, platformColor = BASE_COLORS[0], nextColor = BASE_COLORS[1];
let colorLerp = 0, globalTime = 0;
let screenShakeX = 0, screenShakeY = 0;

// Performance monitoring
let fps = 0, frameCount = 0, lastFpsTime = performance.now();

/* ---------- CANVAS SETUP ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

/* ---------- FIX 1: ANIMATED DEATH EFFECT (Early Version Style) ---------- */
function createAnimatedCrash() {
  const pieces = Math.max(8, Math.floor(20 * (settings.quality.dieEffect / 100)));
  
  for(let i = 0; i < pieces; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 4 + Math.random() * 8;
    const spinSpeed = (Math.random() - 0.5) * 0.2;
    const size = 6 + Math.random() * 12;
    
    crashPieces.push({
      x: player.x + player.width * 0.5,
      y: player.y + player.height * 0.5,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: size,
      color: player.color,
      rotation: Math.random() * Math.PI * 2,
      spinSpeed: spinSpeed,
      life: 60 + Math.random() * 60,
      gravity: 0.2 + Math.random() * 0.3,
      friction: 0.96 + Math.random() * 0.03
    });
  }
  
  // Add explosive particles
  for(let i = 0; i < 15; i++) {
    particles.push({
      x: player.x + player.width * 0.5,
      y: player.y + player.height * 0.5,
      vx: (Math.random() - 0.5) * 12,
      vy: (Math.random() - 1) * 10,
      life: 40 + Math.random() * 40,
      color: "#ff0",
      size: 3 + Math.random() * 5
    });
  }
}

/* ---------- FIX 2: IMPROVED TRAIL EFFECT ---------- */
function updateTrail() {
  // Add new trail point
  trail.push({
    x: player.x,
    y: player.y,
    width: player.width,
    height: player.height,
    color: player.color,
    age: 0 // Start at age 0
  });
  
  // Update ages and remove old trails
  const maxTrail = Math.max(5, Math.floor(20 * (settings.quality.trail / 100)));
  
  for(let i = trail.length - 1; i >= 0; i--) {
    trail[i].age++;
    
    // Remove if too old
    if(trail[i].age > 30) { // 30 ticks = 0.5 seconds at 60 FPS
      trail.splice(i, 1);
    }
  }
  
  // Limit trail length
  if(trail.length > maxTrail) {
    trail.splice(0, trail.length - maxTrail);
  }
}

/* ---------- FIX 3: PROPER BLOCK TEXTURE RENDERING ---------- */
function drawPlatform(plat, camX, camY) {
  // FIXED: runtime.blockTextureEnabled is correct - true means texture ON
  if(runtime.blockTextureEnabled) {
    // Draw texture gradient
    const grd = ctx.createLinearGradient(
      plat.x - camX, plat.y - camY,
      plat.x - camX + plat.width, plat.y - camY + plat.height
    );
    grd.addColorStop(0, `rgba(${plat.color[0]},${plat.color[1]},${plat.color[2]},1)`);
    grd.addColorStop(1, `rgba(${plat.color[0]*0.3},${plat.color[1]*0.3},${plat.color[2]*0.3},1)`);
    
    ctx.fillStyle = grd;
    ctx.fillRect(plat.x - camX, plat.y - camY, plat.width, plat.height);
    
    // Add texture lines
    ctx.strokeStyle = `rgba(255,255,255,0.15)`;
    ctx.lineWidth = 1;
    for(let i = 5; i < plat.width; i += 10) {
      ctx.beginPath();
      ctx.moveTo(plat.x - camX + i, plat.y - camY);
      ctx.lineTo(plat.x - camX + i, plat.y - camY + plat.height);
      ctx.stroke();
    }
  } else {
    // Solid color (no texture)
    ctx.fillStyle = `rgb(${plat.color[0]},${plat.color[1]},${plat.color[2]})`;
    ctx.fillRect(plat.x - camX, plat.y - camY, plat.width, plat.height);
  }
}

/* ---------- NEW EFFECT 1: SCREEN SHAKE ---------- */
function updateScreenShake() {
  if(runtime.screenShakeMul > 0 && (player.onGround || !player.visible)) {
    const intensity = runtime.screenShakeMul * 3;
    screenShakeX = (Math.random() - 0.5) * intensity;
    screenShakeY = (Math.random() - 0.5) * intensity;
  } else {
    screenShakeX *= 0.9;
    screenShakeY *= 0.9;
  }
}

/* ---------- NEW EFFECT 2: ENHANCED PARTICLE PHYSICS ---------- */
function spawnEnhancedParticles(x, y, type, countMultiplier = 1) {
  const baseCount = type === "land" ? 8 : 12;
  const count = Math.floor(baseCount * countMultiplier * runtime.particlePhysicsMul);
  const color = type === "jump" ? "#0ff" : type === "double" ? "#ff0" : "#fff";
  
  for(let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 6 * runtime.particlePhysicsMul;
    
    particles.push({
      x: x + (Math.random() - 0.5) * 10,
      y: y + (Math.random() - 0.5) * 10,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 20 + Math.random() * 30,
      color: color,
      size: 3 + Math.random() * 4,
      gravity: 0.1,
      friction: 0.98
    });
  }
}

/* ---------- NEW EFFECT 3: COLOR INTENSITY ---------- */
function getEnhancedColor(baseColor) {
  if(runtime.colorIntensityMul <= 1) return baseColor;
  
  const intensity = runtime.colorIntensityMul;
  return [
    Math.min(255, baseColor[0] * intensity),
    Math.min(255, baseColor[1] * intensity),
    Math.min(255, baseColor[2] * intensity)
  ];
}

/* ---------- NEW EFFECT 4: MOTION BLUR ---------- */
function addMotionBlur() {
  if(!runtime.motionBlurEnabled || !player.visible) return;
  
  ctx.save();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}

/* ---------- NEW EFFECT 5: AFTER IMAGES ---------- */
function updateAfterImages() {
  if(!runtime.afterImagesEnabled || !player.visible) return;
  
  // Add new after image every 3 frames
  if(frameCount % 3 === 0) {
    afterImages.push({
      x: player.x,
      y: player.y,
      width: player.width,
      height: player.height,
      color: player.color,
      alpha: 0.4,
      life: 10
    });
  }
  
  // Update and clean after images
  for(let i = afterImages.length - 1; i >= 0; i--) {
    const img = afterImages[i];
    img.alpha *= 0.85;
    img.life--;
    
    if(img.life <= 0 || img.alpha < 0.05) {
      afterImages.splice(i, 1);
    }
  }
}

/* ---------- GAME LOGIC ---------- */
function gameTick() {
  if(!gameRunning || !player.visible) return;
  
  // Update effects
  updateScreenShake();
  updateTrail();
  updateAfterImages();
  
  // Game logic
  player.speed += 0.002;
  
  // Color cycling with intensity
  colorLerp += 1/25/TARGET_FPS;
  if(colorLerp >= 1) {
    colorIndex = (colorIndex + 1) % 7;
    nextColor = BASE_COLORS[(colorIndex + 1) % 7];
    colorLerp = 0;
  }
  
  const c1 = BASE_COLORS[colorIndex];
  const c2 = nextColor;
  const baseColor = [
    c1[0] + (c2[0] - c1[0]) * colorLerp,
    c1[1] + (c2[1] - c1[1]) * colorLerp,
    c1[2] + (c2[2] - c1[2]) * colorLerp
  ];
  platformColor = getEnhancedColor(baseColor);
  
  // Physics
  player.y += player.vy;
  player.vy += GRAVITY;
  player.x += player.speed;
  
  // Collision
  player.onGround = false;
  for(const plat of platforms) {
    if(player.x + player.width > plat.x && player.x < plat.x + plat.width &&
       player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + player.vy + 1) {
      if(player.vy >= 0) {
        player.y = plat.y - player.height;
        player.vy = 0;
        player.onGround = true;
        player.jumpsLeft = 2;
        spawnEnhancedParticles(player.x + player.width/2, player.y + player.height, "land");
      }
    }
  }
  
  // Death check
  if(player.y > canvas.height + 300) {
    tryDie();
  }
  
  // Update crash pieces
  for(const piece of crashPieces) {
    piece.x += piece.vx;
    piece.y += piece.vy;
    piece.vy += piece.gravity;
    piece.vx *= piece.friction;
    piece.vy *= piece.friction;
    piece.rotation += piece.spinSpeed;
    piece.life--;
  }
  
  // Cleanup
  for(let i = crashPieces.length - 1; i >= 0; i--) {
    if(crashPieces[i].life <= 0) crashPieces.splice(i, 1);
  }
  for(let i = particles.length - 1; i >= 0; i--) {
    if(particles[i].life-- <= 0) particles.splice(i, 1);
    else {
      particles[i].x += particles[i].vx;
      particles[i].y += particles[i].vy;
      particles[i].vy += (particles[i].gravity || 0);
    }
  }
}

/* ---------- RENDERING ---------- */
function draw() {
  // Apply motion blur if enabled
  if(runtime.motionBlurEnabled) {
    addMotionBlur();
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  
  const camX = cameraX + screenShakeX;
  const camY = cameraY + screenShakeY;
  
  // Draw after images
  if(runtime.afterImagesEnabled) {
    for(const img of afterImages) {
      ctx.save();
      ctx.globalAlpha = img.alpha;
      ctx.fillStyle = img.color;
      ctx.fillRect(img.x - camX, img.y - camY, img.width, img.height);
      ctx.restore();
    }
  }
  
  // Draw platforms with FIXED texture logic
  for(const plat of platforms) {
    drawPlatform(plat, camX, camY);
  }
  
  // Draw trail with improved fade
  for(const t of trail) {
    ctx.save();
    
    // Calculate alpha: full for 3 ticks, then fade over 15 ticks
    let alpha;
    if(t.age <= 3) {
      alpha = 1.0;
    } else {
      const fadeDuration = 15;
      const fadeProgress = (t.age - 3) / fadeDuration;
      alpha = Math.max(0, 1 - fadeProgress * 0.8); // Fade to 20% opacity
    }
    
    ctx.globalAlpha = alpha * 0.6;
    ctx.fillStyle = t.color;
    ctx.fillRect(t.x - camX, t.y - camY, t.width, t.height);
    ctx.restore();
  }
  
  // Draw player
  if(player.visible) {
    ctx.fillStyle = player.color;
    ctx.fillRect(player.x - camX, player.y - camY, player.width, player.height);
  }
  
  // Draw animated crash pieces
  for(const piece of crashPieces) {
    ctx.save();
    ctx.translate(piece.x - camX + piece.size/2, piece.y - camY + piece.size/2);
    ctx.rotate(piece.rotation);
    ctx.fillStyle = piece.color;
    ctx.globalAlpha = Math.min(1, piece.life / 30);
    ctx.fillRect(-piece.size/2, -piece.size/2, piece.size, piece.size);
    ctx.restore();
  }
  
  // Draw particles
  for(const p of particles) {
    ctx.save();
    ctx.globalAlpha = Math.min(1, p.life / 20);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - camX - p.size/2, p.y - camY - p.size/2, p.size, p.size);
    ctx.restore();
  }
  
  // HUD
  document.getElementById('scoreHUD').textContent = 'Score: ' + (score|0);
}

/* ---------- MAIN LOOP ---------- */
let lastTime = 0;
let accumulator = 0;
let rafId = null;

function mainLoop(timestamp) {
  // FPS calculation
  frameCount++;
  if(timestamp - lastFpsTime >= 1000) {
    fps = Math.round((frameCount * 1000) / (timestamp - lastFpsTime));
    document.getElementById('fpsLabel').textContent = 'FPS: ' + fps;
    frameCount = 0;
    lastFpsTime = timestamp;
  }
  
  if(!lastTime) lastTime = timestamp;
  const delta = Math.min(timestamp - lastTime, 100);
  lastTime = timestamp;
  globalTime += delta / 1000;
  
  accumulator += delta;
  
  while(accumulator >= TICK_INTERVAL) {
    gameTick();
    accumulator -= TICK_INTERVAL;
  }
  
  // Camera
  const targetCamX = player.x - 150;
  const targetCamY = player.y - canvas.height*0.5 + player.height*1.5;
  cameraX += (targetCamX - cameraX) * 0.1;
  cameraY += (targetCamY - cameraY) * 0.1;
  
  draw();
  rafId = requestAnimationFrame(mainLoop);
}

/* ---------- GAME CONTROLS ---------- */
function jump() {
  if(!player.visible) return;
  if(player.jumpsLeft > 0) {
    player.vy = JUMP_SPEED;
    spawnEnhancedParticles(player.x + player.width*0.5, player.y + player.height, 
                          player.jumpsLeft === 2 ? "jump" : "double");
    player.jumpsLeft--;
  }
}

function tryDie() {
  if(!player.visible) return;
  if(player.onGround || player.vy > 0) {
    player.visible = false;
    createAnimatedCrash();
    gameRunning = false;
    if(score > bestScore) {
      bestScore = score|0;
      localStorage.setItem('bestScore', bestScore);
    }
    setTimeout(() => {
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('bestScore').textContent = 'Best Score: ' + bestScore;
    }, 1500);
  }
}

/* ---------- INITIALIZATION ---------- */
function resetWorld() {
  platforms = []; spikes = []; gems = []; particles = []; 
  crashPieces = []; trail = []; lines = []; afterImages = [];
  
  player.x = 100;
  player.y = canvas.height*0.5 - player.height;
  player.vy = 0;
  player.speed = 11;
  player.jumpsLeft = 2;
  player.onGround = false;
  player.visible = true;
  
  score = colorLerp = globalTime = 0;
  colorIndex = 0;
  platformColor = BASE_COLORS[0];
  nextColor = BASE_COLORS[1];
  cameraX = cameraY = screenShakeX = screenShakeY = 0;
  
  // Create initial ground
  platforms.push({
    x: 0, y: canvas.height - BLOCK_SIZE*2,
    width: canvas.width, height: BLOCK_SIZE,
    color: BASE_COLORS[0], passed: false
  });
}

/* ---------- EVENT HANDLERS ---------- */
document.getElementById('startBtn').addEventListener('click', () => {
  document.getElementById('menu').style.display = 'none';
  resetWorld();
  gameRunning = true;
  if(!rafId) rafId = requestAnimationFrame(mainLoop);
});

document.getElementById('settingsBtn').addEventListener('click', () => {
  fetch('settings.html', { method: 'HEAD' }).then(resp => {
    if(resp.ok) window.location.href = 'settings.html';
    else alert('settings.html not found');
  }).catch(() => alert('settings.html not found'));
});

window.addEventListener('keydown', e => {
  if(["KeyW","ArrowUp","Space"].includes(e.code)) jump();
  if(e.ctrlKey && e.shiftKey && e.code === 'KeyA') {
    e.preventDefault();
    prompt("Enter command:");
  }
});

window.addEventListener('mousedown', jump);
window.addEventListener('touchstart', jump);
document.getElementById('mobileCommandBtn').addEventListener('click', () => prompt("Enter command:"));

document.getElementById('bestScore').textContent = 'Best Score: ' + bestScore;
document.getElementById('menu').style.display = 'flex';
rafId = requestAnimationFrame(mainLoop);
</script>
</body>
</html>